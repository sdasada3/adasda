local ffi = require("ffi")
local vector = require("vector")
local base64 = require("gamesense/base64")
local clipboard = require("gamesense/clipboard")
local c_entity = require("gamesense/entity")
local images = require('gamesense/images')
local pui = require("gamesense/pui")

local js = panorama.open()

ffi.cdef [[
    struct c_animstate {
        char pad[3];
        char m_bForceWeaponUpdate; // 0x4
        char pad1[91];
        void* m_pBaseEntity; // 0x60
        void* m_pActiveWeapon; // 0x64
        void* m_pLastActiveWeapon; // 0x68
        float m_flLastClientSideAnimationUpdateTime; // 0x6C
        int m_iLastClientSideAnimationUpdateFramecount; // 0x70
        float m_flAnimUpdateDelta; // 0x74
        float m_flEyeYaw; // 0x78
        float m_flGoalFeetYaw; // 0x80
        float m_flCurrentFeetYaw; // 0x80
        float m_angEyeAngles;
        float m_flCurrentFeetYaw; // 0x84   
        float m_flCurrentTorsoYaw; // 0x88
        float m_flSpeedNormalized; // 0xF4
        bool m_bOnGround; // 0x108
    };
]]

local classptr = ffi.typeof('void***')
local rawientitylist = client.create_interface('client.dll', 'VClientEntityList003') or
                           error('VClientEntityList003 not found', 2)

local ientitylist = ffi.cast(classptr, rawientitylist) or error('ientitylist is nil', 2)
local get_client_entity = ffi.cast('void*(__thiscall*)(void*, int)', ientitylist[0][3]) or
                              error('get_client_entity is nil', 2)

local events do
	local event_mt = { } do
        event_mt.__call = function(self, fn, bool)
			local action = bool and client.set_event_callback or client.unset_event_callback
			action(self[1], fn)
		end

		event_mt.set = function(self, fn)
			client.set_event_callback(self[1], fn)
		end

		event_mt.unset = function(self, fn)
			client.unset_event_callback(self[1], fn)
		end

	    event_mt.__index = event_mt
    end


	events = setmetatable({}, {
		__index = function (self, index)
			self[index] = setmetatable({index}, event_mt)
			return self[index]
		end,
	})
end

local ffi_helpers do
    ffi_helpers = {} do
        ffi_helpers.get_client_entity = vtable_bind('client.dll', 'VClientEntityList003', 3, 'void*(__thiscall*)(void***, int)')

        ffi_helpers.animstate = {} do
            if not pcall(ffi.typeof, 'bt_animstate_t') then
                ffi.cdef[[
                    typedef struct {
                        char __0x108[0x108];
                        bool on_ground;
                        bool hit_in_ground_animation;
                    } bt_animstate_t, *pbt_animstate_t
                ]]
            end

            ffi_helpers.animstate.offset = 0x9960

            ffi_helpers.animstate.get = function (self, ent)
                local client_entity = ffi_helpers.get_client_entity(ent)

                if not client_entity then
                    return
                end

                return ffi.cast('pbt_animstate_t*', ffi.cast('uintptr_t', client_entity) + self.offset)[0]
            end
        end

        ffi_helpers.animlayers = {} do
            if not pcall(ffi.typeof, 'bt_animlayer_t') then
                ffi.cdef[[
                    typedef struct {
                        float   anim_time;
                        float   fade_out_time;
                        int     nil;
                        int     activty;
                        int     priority;
                        int     order;
                        int     sequence;
                        float   prev_cycle;
                        float   weight;
                        float   weight_delta_rate;
                        float   playback_rate;
                        float   cycle;
                        int     owner;
                        int     bits;
                    } bt_animlayer_t, *pbt_animlayer_t
                ]]
            end

            ffi_helpers.animlayers.offset = ffi.cast('int*', ffi.cast('uintptr_t', client.find_signature('client.dll', '\x8B\x89\xCC\xCC\xCC\xCC\x8D\x0C\xD1')) + 2)[0]

            ffi_helpers.animlayers.get = function (self, ent)
                local client_entity = ffi_helpers.get_client_entity(ent)

                if not client_entity then
                    return
                end

                return ffi.cast('pbt_animlayer_t*', ffi.cast('uintptr_t', client_entity) + self.offset)[0]
            end
        end

        ffi_helpers.activity = {} do
            if not pcall(ffi.typeof, 'bt_get_sequence') then
                ffi.cdef[[
                    typedef int(__fastcall* bt_get_sequence)(void* entity, void* studio_hdr, int sequence);
                ]]
            end

            ffi_helpers.activity.offset = 0x2950 --- @offset https://github.com/frk1/hazedumper/blob/master/csgo.json#L55
            ffi_helpers.activity.location = ffi.cast('bt_get_sequence', client.find_signature('client.dll', '\x55\x8B\xEC\x53\x8B\x5D\x08\x56\x8B\xF1\x83'))

            ffi_helpers.activity.get = function (self, sequence, ent)
                local client_entity = ffi_helpers.get_client_entity(ent)

                if not client_entity then
                    return
                end

                local studio_hdr = ffi.cast('void**', ffi.cast('uintptr_t', client_entity) + self.offset)[0]

                if not studio_hdr then
                    return;
                end

                return self.location(client_entity, studio_hdr, sequence);
            end
        end

        ffi_helpers.user_input = {} do
            if not pcall(ffi.typeof, 'bt_cusercmd_t') then
                ffi.cdef[[
                    typedef struct {
                        struct bt_cusercmd_t (*cusercmd)();
                        int     command_number;
                        int     tick_count;
                        float   view[3];
                        float   aim[3];
                        float   move[3];
                        int     buttons;
                    } bt_cusercmd_t;
                ]]
            end

            if not pcall(ffi.typeof, 'bt_get_usercmd') then
                ffi.cdef[[
                    typedef bt_cusercmd_t*(__thiscall* bt_get_usercmd)(void* input, int, int command_number);
                ]]
            end

            ffi_helpers.user_input.vtbl = ffi.cast('void***', ffi.cast('void**', ffi.cast('uintptr_t', client.find_signature('client.dll', '\xB9\xCC\xCC\xCC\xCC\x8B\x40\x38\xFF\xD0\x84\xC0\x0F\x85') or error('fipp')) + 1)[0])
            ffi_helpers.user_input.location = ffi.cast('bt_get_usercmd', ffi_helpers.user_input.vtbl[0][8])

            ffi_helpers.user_input.get_command = function (self, command_number)
                return self.location(self.vtbl, 0, command_number)
            end
        end
    end
end

local math_helpers do
    math.clamp = function (x, a, b) if a > x then return a elseif b < x then return b else return x end end

    math.normalize_yaw = function(yaw)
        while yaw > 180 do yaw = yaw - 360 end
        while yaw < -180 do yaw = yaw + 360 end
        return yaw
    end
    
    math.normalize_angle = function(angle)
        while angle > 180 do
            angle = angle - 360
        end
        while angle < -180 do
            angle = angle + 360
        end
        return angle
    end
end

lerp = function(a, b, t)
    return a + t * (b - a)
end

local animations = { } do
    animations.max_lerp_low_fps = (1 / 45) * 100
    animations.color_lerp = function(start, end_pos, time)
        local frametime = globals.frametime() * 100
        time = time * math.min(frametime, animations.max_lerp_low_fps)
        return lerp(start, end_pos, time)
    end
    
    animations.lerp = function(start, end_pos, time)
        if start == end_pos then
            return end_pos
        end
    
        local frametime = globals.frametime() * 170
        time = time * math.min(frametime, animations.max_lerp_low_fps)
    
        local val = start + (end_pos - start) * math.clamp(time, 0.01, 1)
    
        if(math.abs(val - end_pos) < 0.01) then
            return end_pos
        end
    
        return val
    end

    animations.base_speed = 0.095
    animations._list = {}

    animations.new = function(name, new_value, speed, init)
        speed = speed or animations.base_speed
        
        local is_color = type(new_value) == "userdata"

        if animations._list[name] == nil then
            animations._list[name] = (init and init) or (is_color and color(255) or 0)
        end

        local interp_func

        if is_color then
            interp_func = animations.color_lerp
        else
            interp_func = animations.lerp
        end

        animations._list[name] = interp_func(animations._list[name], new_value, speed)
        
        return animations._list[name]
    end
end

local screen_x, screen_y = client.screen_size()

local vars = { } do
    vars.anti_aim = { }

    vars.anti_aim.states = {"Shared", "Standing", "Moving", "Air", "Air+", "Crouching", "Crouching+", "Slow-Walking", "Freestand", "Manual Yaw"}
    vars.anti_aim.references = {
        pitch = {'Off', 'Default', 'Up', 'Down', 'Minimal', 'Random'},
        yaw = {'Off', '180', 'Spin', 'Static', '180 Z', 'Crosshair'},
        yaw_base = {"Local view", "At targets"},
        elements = {
            anti_aim = {pui.reference("AA", "Anti-aimbot angles", "Enabled")},
            pitch = {pui.reference("AA", "Anti-aimbot angles", "Pitch")},
            yaw = {pui.reference("AA", "Anti-aimbot angles", "Yaw")},
            yawbase = pui.reference("AA", "Anti-aimbot angles", "Yaw Base"),
            yawjitter = { pui.reference("AA", "Anti-aimbot angles", "Yaw jitter") },
            bodyyaw = { pui.reference("AA", "Anti-aimbot angles", "Body yaw") },
            fs_body_yaw = pui.reference("AA", "Anti-aimbot angles", "Freestanding body yaw"),
            roll = pui.reference("AA", "Anti-aimbot angles", "Roll"),
            freeStand = pui.reference("AA", "Anti-aimbot angles", "Freestanding"),
            edgeyaw = pui.reference("AA", "Anti-aimbot angles", "Edge yaw"),
            fake_duck = pui.reference("RAGE", "Other", "Duck peek assist"),
            slow_motion = pui.reference("AA", "Other", "Slow motion"),
            fake_lag = {
                enabled = pui.reference("AA", "Fake lag", "Enabled"),
                amount = pui.reference("AA", "Fake lag", "Amount"),
                variance = pui.reference("AA", "Fake lag", "Variance"),
                limit = pui.reference("AA", "Fake lag", "Limit"),
            },
            other = {
                leg_movement = pui.reference("AA", "Other", "Leg movement"),
                os_aa = pui.reference("AA", "Other", "On shot anti-aim"),
                fake_peek = pui.reference("AA", "Other", "Fake peek"),
            },
        },
    }

    vars.rage_bot = { }
    vars.rage_bot.references = {
        enabled = pui.reference('RAGE', 'Aimbot', 'Enabled'),
        double_tap = {pui.reference('RAGE', 'Aimbot', 'Double tap')},
        double_tap_fl_limit = pui.reference('RAGE', 'Aimbot', 'Double tap fake lag limit'),
        hide_shots = pui.reference('AA', 'Other', 'On shot anti-aim'),
        minimum_hitchance = {pui.reference('RAGE', 'Aimbot', 'Minimum hit chance')},
        minimum_damage = {pui.reference('RAGE', 'Aimbot', 'Minimum damage')},
        minimum_damage_override = {pui.reference('RAGE', 'Aimbot', 'Minimum damage override')}
    }

    vars.visuals = { }
    vars.visuals.references = {
        scope_overlay = pui.reference('VISUALS', 'Effects', 'Remove scope overlay'),
    }

    vars.misc = { }
    vars.misc.references = {
        override_fov = pui.reference('MISC', 'Miscellaneous', 'Override FOV'),
        ping_spike = {pui.reference('MISC', 'Miscellaneous', 'Ping spike')},
    }
end

local menu = { } do
    menu.tabs_path = {
        anti_aim = {
            general = pui.group("AA", "Anti-aimbot angles"),
            fake_lag = pui.group("AA", "Fake lag"),
            other = pui.group("AA", "Other"),
        }
    }

    menu.tab_switcher = menu.tabs_path.anti_aim.general:combobox("\n", {"Home", "Anti-aim", "Other"})

    menu.nyahook_label = menu.tabs_path.anti_aim.fake_lag:label("Welcome to \vNyaHook!"):depend({ menu.tab_switcher, "Home" })
    menu.user = menu.tabs_path.anti_aim.fake_lag:label("User: \vadmin"):depend({ menu.tab_switcher, "Home" })
    menu.branch = menu.tabs_path.anti_aim.fake_lag:label("Branch: \vDebug"):depend({ menu.tab_switcher, "Home" })

    menu.configs = { } do
        menu.configs.list = menu.tabs_path.anti_aim.general:listbox("\n", {})
        menu.configs.name = menu.tabs_path.anti_aim.general:textbox("\n")
        menu.configs.create = menu.tabs_path.anti_aim.general:button("Create", function() end)
        menu.configs.load = menu.tabs_path.anti_aim.general:button("Load", function() end)
        menu.configs.save = menu.tabs_path.anti_aim.general:button("Save", function() end)
        menu.configs.delete = menu.tabs_path.anti_aim.general:button("Delete", function() end)
        menu.configs.import = menu.tabs_path.anti_aim.general:button("Import", function() end)
        menu.configs.export = menu.tabs_path.anti_aim.general:button("Export", function() end)
    end

    menu.anti_aim = { } do
        menu.anti_aim.current_state = menu.tabs_path.anti_aim.general:combobox("\n", vars.anti_aim.states)

        menu.anti_aim.manual_yaw_left = menu.tabs_path.anti_aim.fake_lag:hotkey("Left")
        menu.anti_aim.manual_yaw_right = menu.tabs_path.anti_aim.fake_lag:hotkey("Right")
        menu.anti_aim.manual_yaw_forward = menu.tabs_path.anti_aim.fake_lag:hotkey("Forward")
        menu.anti_aim.freestand_hotkey = menu.tabs_path.anti_aim.fake_lag:hotkey("Freestand")
    
        menu.anti_aim.tweaks = menu.tabs_path.anti_aim.fake_lag:multiselect("Tweaks", {"Avoid backstab", "Fast ladder", "Safe head", "Unsafe charge", "Flick exploit"})
    
        menu.anti_aim.avoid_backstab_distance = menu.tabs_path.anti_aim.fake_lag:slider("Distance", 150, 400, 250, true, "ft", 1)
    
        menu.anti_aim.safe_head_states = menu.tabs_path.anti_aim.fake_lag:multiselect("Safe Head States", {"Knife", "Taser", "Above enemy"})
        menu.anti_aim.e_spam = menu.tabs_path.anti_aim.fake_lag:checkbox("E-Spam")
        menu.anti_aim.height_difference = menu.tabs_path.anti_aim.fake_lag:slider("Height difference", 50, 150, 70, true, "ft", 1)

        menu.anti_aim.flick_direction = menu.tabs_path.anti_aim.fake_lag:slider("Direction", -180, 180, 20, true, "", 1)
        menu.anti_aim.flick_yaw_type = menu.tabs_path.anti_aim.fake_lag:combobox("Flick type", {"Default", "Switch"})
        menu.anti_aim.flick_yaw = menu.tabs_path.anti_aim.fake_lag:slider("Flick yaw", -180, 180, 120, true, "", 1)
        menu.anti_aim.flick_yaw_min = menu.tabs_path.anti_aim.fake_lag:slider("Flick yaw ~ \vMin\r", -180, 180, 120, true, "", 1)
        menu.anti_aim.flick_yaw_max = menu.tabs_path.anti_aim.fake_lag:slider("Flick yaw ~ \vMax\r", -180, 180, 120, true, "", 1)

        menu.anti_aim.export_preset = menu.tabs_path.anti_aim.other:button("Export \vPreset\r")
        menu.anti_aim.import_preset = menu.tabs_path.anti_aim.other:button("Import \vPreset\r")
    end

    menu.anti_aim.builder = { }

    for k, state in ipairs(vars.anti_aim.states) do
        menu.anti_aim.builder[k] = {
            enable_state = menu.tabs_path.anti_aim.general:checkbox("Override \v" .. state),
            pitch = menu.tabs_path.anti_aim.general:combobox("Pitch\n" .. state, vars.anti_aim.references.pitch),
            yaw_amount = menu.tabs_path.anti_aim.general:slider("Yaw Amount\n" .. state, -180, 180, 0, true, "°", 1),
            add_left_right = menu.tabs_path.anti_aim.general:checkbox("Add \vleft/right\n" .. state),
            left_right_type = menu.tabs_path.anti_aim.general:combobox("\n" .. state, {"Default", "Phases"}),
    
            yaw_left_phase_1 = menu.tabs_path.anti_aim.general:slider("\v[1]\r Add Left\n" .. state, -180, 180, 0, true, "°", 1),
            yaw_right_phase_1 = menu.tabs_path.anti_aim.general:slider("\v[1]\r Add Right\n" .. state, -180, 180, 0, true, "°", 1),
    
            yaw_left_phase_2 = menu.tabs_path.anti_aim.general:slider("\v[2]\r Add Left\n" .. state, -180, 180, 0, true, "°", 1),
            yaw_right_phase_2 = menu.tabs_path.anti_aim.general:slider("\v[2]\r Add Right\n" .. state, -180, 180, 0, true, "°", 1),
    
            yaw_left_phase_3 = menu.tabs_path.anti_aim.general:slider("\v[3]\r Add Left\n" .. state, -180, 180, 0, true, "°", 1),
            yaw_right_phase_3 = menu.tabs_path.anti_aim.general:slider("\v[3]\r Add Right\n" .. state, -180, 180, 0, true, "°", 1),
    
            phase_speed = menu.tabs_path.anti_aim.general:slider("Switch Speed\n" .. state, 1, 10, 1, true, "", 1, {[1] = "Default"}),
    
            yaw_left = menu.tabs_path.anti_aim.general:slider("Add Left\n" .. state, -180, 180, 0, true, "°", 1),
            yaw_right = menu.tabs_path.anti_aim.general:slider("Add Right\n" .. state, -180, 180, 0, true, "°", 1),
    
            yaw_randomize = menu.tabs_path.anti_aim.general:slider("Randomize\n" .. state, 0, 100, 0, true, "%", 1),
    
            yaw_jitter = menu.tabs_path.anti_aim.general:combobox("Yaw jitter\n" .. state, {"Off", "Center", "Random", "3-Way"}),
            yaw_jitter_amount = menu.tabs_path.anti_aim.general:slider("\n \n" .. state, -180, 180, 0, true, "°", 1),
    
            body_yaw = menu.tabs_path.anti_aim.general:combobox("Body yaw\n" .. state, {"Off", "Opposite", "Jitter", "Static"}),
            jitter_delay = menu.tabs_path.anti_aim.general:slider("Jitter Delay\n" .. state, 1, 15, 0, true, "t", 1, {[1] = "Gamesense"}),
            hold_ticks = menu.tabs_path.anti_aim.general:slider("Hold ticks\n" .. state, 1, 50, 0, true, "t", 1, {[1] = "Disabled"}),
            jitter_delay_randomize = menu.tabs_path.anti_aim.general:slider("Randomize Delay\n" .. state, 1, 15, 0, true, "t", 1, {[1] = "Disabled"}),

            force_defensive = menu.tabs_path.anti_aim.general:checkbox("Force defensive\n" .. state),
            defensive_options = menu.tabs_path.anti_aim.general:combobox("\n" .. state, {"On Peek", "Always On"}),
    
            defensive_aa = menu.tabs_path.anti_aim.general:checkbox("\vDefensive\r AA\n" .. state),
    
            defensive_pitch = menu.tabs_path.anti_aim.general:combobox("\vDefensive\r ~ Pitch\n" .. state, {"Disabled", "Down", "Up", "Random", "Sway", "Custom"}),
            defensive_pitch_random_1 = menu.tabs_path.anti_aim.general:slider("\vRandom\r ~ Min\n" .. state, -89, 89, 0, true, "°"),
            defensive_pitch_random_2 = menu.tabs_path.anti_aim.general:slider("\vRandom\r ~ Max\n" .. state, -89, 89, 0, true, "°"),
            defensive_pitch_sway_speed = menu.tabs_path.anti_aim.general:slider("\vSway\r ~ Speed\n" .. state, 1, 20, 1, true, ""),
            defensive_pitch_custom = menu.tabs_path.anti_aim.general:slider("\vCustom\r ~ Value\n" .. state, -89, 89, 0, true, "°"),
    
            defensive_yaw = menu.tabs_path.anti_aim.general:combobox("\vDefensive\r ~ Yaw\n" .. state, {"Sideways", "Side-based", "Spin", "Random", "Custom"}),
            defensive_yaw_left_yaw = menu.tabs_path.anti_aim.general:slider("\vSide-based\r ~ Left Yaw\n" .. state, -180, 180, 0, true, "°", 1),
            defensive_yaw_right_yaw = menu.tabs_path.anti_aim.general:slider("\vSide-based\r ~ Right Yaw\n" .. state, -180, 180, 0, true, "°", 1),
            defensive_yaw_spin_speed = menu.tabs_path.anti_aim.general:slider("\vSpin\r ~ Speed\n" .. state, 1, 15, 1, true, "", 1),
            defensive_yaw_random_1 = menu.tabs_path.anti_aim.general:slider("\vRandom\r ~ Min\n" .. state .. "_yaw", -180, 180, 0, true, "°", 1),
            defensive_yaw_random_2 = menu.tabs_path.anti_aim.general:slider("\vRandom\r ~ Max\n" .. state .. "_yaw", -180, 180, 0, true, "°", 1),
            defensive_yaw_custom = menu.tabs_path.anti_aim.general:slider("\vCustom\r ~ Value\n" .. state .. "_yaw", -180, 180, 0, true, "°", 1),
        }
    end

    menu.other = { } do 
        menu.other.visuals = { } do
            menu.watermark_color_label = menu.tabs_path.anti_aim.general:label("Accent color"):depend({ menu.tab_switcher, "Other" })
            menu.watermark_color = menu.tabs_path.anti_aim.general:color_picker("Accent color", 255, 255, 255, 255):depend({ menu.tab_switcher, "Other" })
            
            menu.other.visuals.watermark = menu.tabs_path.anti_aim.general:checkbox("Watermark")
            menu.other.visuals.watermark_color = menu.tabs_path.anti_aim.general:color_picker("Color", 255, 255, 255, 255)
            menu.other.visuals.watermark_style = menu.tabs_path.anti_aim.general:combobox("Style", {"Default", "Modern"})

            menu.other.visuals.exploit_indication = menu.tabs_path.anti_aim.general:checkbox("\vExploit\r indication")
            menu.other.visuals.exploit_indication_color = menu.tabs_path.anti_aim.general:color_picker("Color", 255, 255, 255, 255)

            -- menu.other.visuals.crosshair_indicators = menu.tabs_path.anti_aim.general:checkbox("Crosshair indicators")
            -- menu.other.visuals.crosshair_indicators_color = menu.tabs_path.anti_aim.general:color_picker("\nCrosshair indicators", 255, 255, 255, 255)
            -- menu.other.visuals.crosshair_indicators_offset = menu.tabs_path.anti_aim.general:slider("\vCrosshair indicators\r ~ Offset", 15, 100, 0)
        
            menu.other.visuals.damage_indicator = menu.tabs_path.anti_aim.general:checkbox("Damage indicator")
        
            menu.other.visuals.manual_arrows = menu.tabs_path.anti_aim.general:checkbox("Manual Arrows")
            menu.other.visuals.manual_arrows_style = menu.tabs_path.anti_aim.general:combobox("Style", {"Classic", "Modern"})
            menu.other.visuals.manual_arrows_color = menu.tabs_path.anti_aim.general:color_picker("Color", 255, 255, 255, 255)
        
            menu.other.visuals.cross_marker = menu.tabs_path.anti_aim.general:checkbox("Cross marker")
        
            menu.other.visuals.custom_scope_overlay = menu.tabs_path.anti_aim.general:checkbox("Custom scope overlay")
            menu.other.visuals.custom_scope_overlay_color = menu.tabs_path.anti_aim.general:color_picker("Color", 255, 255, 255, 255)
            menu.other.visuals.custom_scope_overlay_gap = menu.tabs_path.anti_aim.general:slider("Gap", 0, 50, 5)
            menu.other.visuals.custom_scope_overlay_size = menu.tabs_path.anti_aim.general:slider("Size", 15, 300, 100)

            menu.other.visuals.animated_zoom = menu.tabs_path.anti_aim.general:checkbox("Animated zoom")
            menu.other.visuals.animated_zoom_fov = menu.tabs_path.anti_aim.general:slider("Zoom FOV", 0, 100, 10, true, "%", 1)
            menu.other.visuals.animated_zoom_second_fov = menu.tabs_path.anti_aim.general:slider("Second Zoom FOV", 0, 100, 50, true, "%", 1)

            menu.other.visuals.aspect_ratio = menu.tabs_path.anti_aim.general:checkbox("Aspect Ratio")
            menu.other.visuals.aspect_ratio_value = menu.tabs_path.anti_aim.general:slider("Value", 0, 200, 0, true, "", 0.01)
        end
    
        menu.other.misc = { } do
            menu.other.misc.aimbot_logs = menu.tabs_path.anti_aim.other:checkbox("Aimbot logs")
            menu.other.misc.notify_output = menu.tabs_path.anti_aim.other:checkbox("Notify output")
            menu.other.misc.hit_color_label = menu.tabs_path.anti_aim.other:label("Hit color")
            menu.other.misc.hit_color = menu.tabs_path.anti_aim.other:color_picker("Hit color", 255, 255, 255, 255)
            menu.other.misc.miss_color_label = menu.tabs_path.anti_aim.other:label("Miss color")
            menu.other.misc.miss_color = menu.tabs_path.anti_aim.other:color_picker("Miss color", 255, 255, 255, 255)

            menu.other.misc.animations = menu.tabs_path.anti_aim.other:checkbox("Animations")
            menu.other.misc.ground_legs = menu.tabs_path.anti_aim.other:combobox("Ground legs", {"Walking", "Jitter", "Moonwalk"})
            menu.other.misc.ground_legs_type = menu.tabs_path.anti_aim.other:combobox("Type", {"Full", "Randomized", "Flex"})
            menu.other.misc.air_legs = menu.tabs_path.anti_aim.other:combobox("Air legs", {"Disabled", "Static", "Jitter", "Moonwalk"})
            menu.other.misc.addons = menu.tabs_path.anti_aim.other:multiselect("Addons", {"Body Lean", "Earthquake", "Pitch 0 on land"})

            menu.other.misc.console_filter = menu.tabs_path.anti_aim.other:checkbox("Console filter")

            menu.other.misc.aim_tools = menu.tabs_path.anti_aim.fake_lag:checkbox("Aimtools \aFF4C4CFF[BETA]\r") do 
                menu.other.misc.jitter_correction = menu.tabs_path.anti_aim.fake_lag:checkbox("Jitter correction")
                menu.other.misc.jitter_correction_debug = menu.tabs_path.anti_aim.fake_lag:checkbox("ESP Debug")
                menu.other.misc.jitter_correction_mode = menu.tabs_path.anti_aim.fake_lag:combobox("Mode", {"Default", "Experiemental"})
    
                -- menu.other.misc.air_stop = menu.tabs_path.anti_aim.fake_lag:checkbox("Air \vstop\r")
                -- menu.other.misc.air_stop_auto_scope = menu.tabs_path.anti_aim.fake_lag:checkbox("\vAir stop\r ~ Auto-scope")
                -- menu.other.misc.air_stop_dt_uncharge = menu.tabs_path.anti_aim.fake_lag:checkbox("\vAir stop\r ~ Auto DT Uncharge")
                -- menu.other.misc.air_stop_minimum_hitchance = menu.tabs_path.anti_aim.fake_lag:slider("\vAir stop\r ~ Minimum Hitchance", 0, 100, 1, true, "%", 1)
                -- menu.other.misc.air_stop_damage_multiplier = menu.tabs_path.anti_aim.fake_lag:slider("\vAir stop\r ~ Damage Multiplier", 1, 100, 1, true, "", 1)
                -- menu.other.misc.air_stop_accuracy_boost = menu.tabs_path.anti_aim.fake_lag:combobox("\vAir stop\r ~ Accuracy Boost", {"Low", "Medium", "High", "Maximum"})
            end
        end
    end

    local menu_depends do
        for k, v in ipairs(vars.anti_aim.states) do
            local is_state = { menu.anti_aim.current_state, vars.anti_aim.states[k] }
            local is_state_enabled = { menu.anti_aim.builder[k].enable_state, function() if k == 1 then return true else return menu.anti_aim.builder[k].enable_state.value end end }
            local can_enable_state = { menu.anti_aim.builder[k].enable_state, function() return k ~= 1 end }
    
            local is_left_right = { menu.anti_aim.builder[k].add_left_right, true }

            local is_left_right_default = { menu.anti_aim.builder[k].left_right_type, "Default" }
            local is_left_right_phase = { menu.anti_aim.builder[k].left_right_type, "Phases" }
    
            local is_jitter = { menu.anti_aim.builder[k].yaw_jitter, function() return menu.anti_aim.builder[k].yaw_jitter.value ~= "Off" end }
    
            local is_body_yaw = { menu.anti_aim.builder[k].body_yaw, function() return menu.anti_aim.builder[k].body_yaw.value ~= "Off" end }
            local is_jitter_body = { menu.anti_aim.builder[k].body_yaw, function() return menu.anti_aim.builder[k].body_yaw.value == "Jitter" end }

            local is_forcing_defensive = { menu.anti_aim.builder[k].force_defensive, true }

            local is_defensive_aa = { menu.anti_aim.builder[k].defensive_aa, true }
            local is_defensive_random_pitch = { menu.anti_aim.builder[k].defensive_pitch, "Random" }
            local is_defensive_sway_pitch = { menu.anti_aim.builder[k].defensive_pitch, "Sway" }
            local is_defensive_custom_pitch = { menu.anti_aim.builder[k].defensive_pitch, "Custom" }
            local is_defensive_random_yaw = { menu.anti_aim.builder[k].defensive_yaw, "Random" }
            local is_defensive_custom_yaw = { menu.anti_aim.builder[k].defensive_yaw, "Custom" }
            local is_defensive_side_based = { menu.anti_aim.builder[k].defensive_yaw, "Side-based" }
            local is_defensive_spin = { menu.anti_aim.builder[k].defensive_yaw, "Spin" }
    
            menu.anti_aim.builder[k].enable_state:depend( is_state, can_enable_state )
            menu.anti_aim.builder[k].pitch:depend( is_state, is_state_enabled )
            menu.anti_aim.builder[k].yaw_amount:depend( is_state, is_state_enabled )
            menu.anti_aim.builder[k].add_left_right:depend( is_state, is_state_enabled )

            menu.anti_aim.builder[k].left_right_type:depend( is_state, is_state_enabled, is_left_right ) do
                menu.anti_aim.builder[k].yaw_left_phase_1:depend( is_state, is_state_enabled, is_left_right, is_left_right_phase )
                menu.anti_aim.builder[k].yaw_right_phase_1:depend( is_state, is_state_enabled, is_left_right, is_left_right_phase )

                menu.anti_aim.builder[k].yaw_left_phase_2:depend( is_state, is_state_enabled, is_left_right, is_left_right_phase )
                menu.anti_aim.builder[k].yaw_right_phase_2:depend( is_state, is_state_enabled, is_left_right, is_left_right_phase )

                menu.anti_aim.builder[k].yaw_left_phase_3:depend( is_state, is_state_enabled, is_left_right, is_left_right_phase )
                menu.anti_aim.builder[k].yaw_right_phase_3:depend( is_state, is_state_enabled, is_left_right, is_left_right_phase )

                menu.anti_aim.builder[k].phase_speed:depend( is_state, is_state_enabled, is_left_right, is_left_right_phase )

                menu.anti_aim.builder[k].yaw_left:depend( is_state, is_state_enabled, is_left_right, is_left_right_default )
                menu.anti_aim.builder[k].yaw_right:depend( is_state, is_state_enabled, is_left_right, is_left_right_default )
            end

            menu.anti_aim.builder[k].yaw_randomize:depend( is_state, is_state_enabled, is_left_right )
            menu.anti_aim.builder[k].yaw_jitter:depend( is_state, is_state_enabled )
            menu.anti_aim.builder[k].yaw_jitter_amount:depend( is_state, is_state_enabled, is_jitter )
            menu.anti_aim.builder[k].body_yaw:depend( is_state, is_state_enabled )
            menu.anti_aim.builder[k].jitter_delay:depend( is_state, is_state_enabled, is_body_yaw, is_jitter_body )
            menu.anti_aim.builder[k].hold_ticks:depend( is_state, is_state_enabled, is_body_yaw, is_jitter_body )
            menu.anti_aim.builder[k].jitter_delay_randomize:depend( is_state, is_state_enabled, is_body_yaw, is_jitter_body )

            menu.anti_aim.builder[k].force_defensive:depend( is_state, is_state_enabled )
            menu.anti_aim.builder[k].defensive_options:depend( is_state, is_state_enabled, is_forcing_defensive )

            menu.anti_aim.builder[k].defensive_aa:depend( is_state, is_state_enabled, is_forcing_defensive ) do
                menu.anti_aim.builder[k].defensive_pitch:depend( is_state, is_state_enabled, is_defensive_aa, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_pitch_random_1:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_random_pitch, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_pitch_random_2:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_random_pitch, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_pitch_sway_speed:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_sway_pitch, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_pitch_custom:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_custom_pitch, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_yaw:depend( is_state, is_state_enabled, is_defensive_aa, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_yaw_left_yaw:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_side_based, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_yaw_right_yaw:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_side_based, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_yaw_spin_speed:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_spin, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_yaw_random_1:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_random_yaw, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_yaw_random_2:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_random_yaw, is_forcing_defensive )
                menu.anti_aim.builder[k].defensive_yaw_custom:depend( is_state, is_state_enabled, is_defensive_aa, is_defensive_custom_yaw, is_forcing_defensive )
            end
        end

        menu.anti_aim.avoid_backstab_distance:depend({ menu.anti_aim.tweaks, "Avoid backstab" })

        menu.anti_aim.safe_head_states:depend({ menu.anti_aim.tweaks, "Safe head" })
        menu.anti_aim.e_spam:depend({ menu.anti_aim.tweaks, "Safe head" })
        menu.anti_aim.height_difference:depend({ menu.anti_aim.tweaks, "Safe head" }, { menu.anti_aim.safe_head_states, "Above enemy" })

        menu.anti_aim.flick_direction:depend({ menu.anti_aim.tweaks, "Flick exploit" })
        menu.anti_aim.flick_yaw_type:depend({ menu.anti_aim.tweaks, "Flick exploit" })
        menu.anti_aim.flick_yaw:depend({ menu.anti_aim.tweaks, "Flick exploit" }, { menu.anti_aim.flick_yaw_type, "Default" })
        menu.anti_aim.flick_yaw_min:depend({ menu.anti_aim.tweaks, "Flick exploit" }, { menu.anti_aim.flick_yaw_type, "Switch" })
        menu.anti_aim.flick_yaw_max:depend({ menu.anti_aim.tweaks, "Flick exploit" }, { menu.anti_aim.flick_yaw_type, "Switch" })

        menu.watermark_color_label:depend({ menu.other.visuals.watermark, false })
        menu.watermark_color:depend({ menu.other.visuals.watermark, false })

        menu.other.visuals.watermark_color:depend({ menu.other.visuals.watermark, true })
        menu.other.visuals.watermark_style:depend({ menu.other.visuals.watermark, true })

        menu.other.visuals.exploit_indication_color:depend({ menu.other.visuals.exploit_indication, true })
    
        -- menu.other.visuals.crosshair_indicators_color:depend({ menu.other.visuals.crosshair_indicators, true })
        -- menu.other.visuals.crosshair_indicators_offset:depend({ menu.other.visuals.crosshair_indicators, true })
    
        menu.other.visuals.manual_arrows_style:depend({ menu.other.visuals.manual_arrows, true })
        menu.other.visuals.manual_arrows_color:depend({ menu.other.visuals.manual_arrows, true })
    
        menu.other.visuals.custom_scope_overlay_gap:depend({ menu.other.visuals.custom_scope_overlay, true })
        menu.other.visuals.custom_scope_overlay_size:depend({ menu.other.visuals.custom_scope_overlay, true })
        menu.other.visuals.custom_scope_overlay_color:depend({ menu.other.visuals.custom_scope_overlay, true })

        menu.other.visuals.animated_zoom_fov:depend({ menu.other.visuals.animated_zoom, true })
        menu.other.visuals.animated_zoom_second_fov:depend({ menu.other.visuals.animated_zoom, true })

        menu.other.visuals.aspect_ratio_value:depend({ menu.other.visuals.aspect_ratio, true })
    
        menu.other.misc.notify_output:depend({ menu.other.misc.aimbot_logs, true })
        menu.other.misc.hit_color_label:depend({ menu.other.misc.aimbot_logs, true }, { menu.other.misc.notify_output, true })
        menu.other.misc.miss_color_label:depend({ menu.other.misc.aimbot_logs, true }, { menu.other.misc.notify_output, true })
        menu.other.misc.hit_color:depend({ menu.other.misc.aimbot_logs, true }, { menu.other.misc.notify_output, true })
        menu.other.misc.miss_color:depend({ menu.other.misc.aimbot_logs, true }, { menu.other.misc.notify_output, true })

        menu.other.misc.ground_legs:depend({ menu.other.misc.animations, true })
        menu.other.misc.ground_legs_type:depend({ menu.other.misc.animations, true }, { menu.other.misc.ground_legs, "Jitter" })
        menu.other.misc.air_legs:depend({ menu.other.misc.animations, true })
        menu.other.misc.addons:depend({ menu.other.misc.animations, true })

        menu.other.misc.jitter_correction:depend({ menu.other.misc.aim_tools, true })
        menu.other.misc.jitter_correction_debug:depend({ menu.other.misc.jitter_correction, true }, { menu.other.misc.aim_tools, true })
        menu.other.misc.jitter_correction_mode:depend({ menu.other.misc.jitter_correction, true }, { menu.other.misc.aim_tools, true })

        -- menu.other.misc.air_stop_auto_scope:depend({ menu.other.misc.air_stop, true })
        -- menu.other.misc.air_stop_dt_uncharge:depend({ menu.other.misc.air_stop, true })
        -- menu.other.misc.air_stop_damage_multiplier:depend({ menu.other.misc.air_stop, true })
        -- menu.other.misc.air_stop_accuracy_boost:depend({ menu.other.misc.air_stop, true })
    end
end

local anti_aim = { } do
    anti_aim.data = {
        state_id = 0,
        inverter = false,
        ticks = 0,
        switch = false,
        default_yaw_amount = 0,
        add_left_yaw = 0,
        add_right_yaw = 0,
        delay_value = 0,
        hold_ticks_value = 0,
        yaw_spin_speed = 0,
        manual_yaw_direction = 0,
        last_pushed_button = 0,
        safe_trigger = false,
        pitch = {
            types = "Off",
            custom_amount = 0
        },
        yaw = {
            base = "At targets",
            type = "Off",
            degree = 0,
            jitter = {
                type = "Off",
                amount = 0
            }
        },
        body_yaw = {
            type = "Off",
            amount = 0
        },
        freestanding = false
    }

    anti_aim.condition_func = 
    { 
        onground_ticks = 0,
        in_air = function (indx)
            flags = entity.get_prop(indx, "m_fFlags")

            return bit.band(flags, 1) == 0
        end,
        is_onground = function(indx)
            local animstate = ffi_helpers.animstate:get(indx)
            if not animstate then return true end

            local ptr_addr = ffi.cast('uintptr_t', ffi.cast('void*', animstate))
            local landed_on_ground_this_frame = ffi.cast('bool*', ptr_addr + 0x120)[0] --- @offset

            return animstate.on_ground and not landed_on_ground_this_frame
        end,
        velocity = function(indx)
            vel_x, vel_y = entity.get_prop(indx, "m_vecVelocity")
            local velocity = math.sqrt(vel_x * vel_x + vel_y * vel_y)
            
            return velocity
        end,
        is_crouching = function (indx)
            return entity.get_prop(indx, "m_flDuckAmount") > 0.8
        end
    }

    anti_aim.get_desync_side = function(cmd)
        local lp = entity.get_local_player()
        if lp == nil then return end
    
        local body_yaw = entity.get_prop(lp, "m_flPoseParameter", 11) * 120 - 60
    
        return body_yaw > 0
    end

    anti_aim.get_state = function()
        local lp = entity.get_local_player()
        if lp == nil then return end

        if anti_aim.data.manual_yaw_direction ~= 0 then
            return 10
        end

        local freestand_hotkey = menu.anti_aim.freestand_hotkey:get()

        if freestand_hotkey then
            return 9
        end

        if not anti_aim.condition_func.is_onground(lp) then
            if anti_aim.condition_func.is_crouching(lp) then
                return 5
            else
                return 4
            end
        end

        local fake_duck_state = vars.anti_aim.references.elements.fake_duck:get()

        if anti_aim.condition_func.is_crouching(lp) or fake_duck_state then
            if anti_aim.condition_func.velocity(lp) > 4 then
                return 7
            else
                return 6
            end
        end

        local slow_motion_state = vars.anti_aim.references.elements.slow_motion.hotkey:get()

        if slow_motion_state then
            return 8
        end

        if anti_aim.condition_func.is_onground(lp) and anti_aim.condition_func.velocity(lp) > 4 then
            return 3
        end

        return 2
    end

    anti_aim.exploit = { } do
        anti_aim.exploit.breaker = { }

        anti_aim.exploit.breaker.tick = 0
        anti_aim.exploit.breaker.cmd = 0
        anti_aim.exploit.breaker.check = 0
        anti_aim.exploit.charged = 0

        anti_aim.exploit.get = function()
            local lp = entity.get_local_player()
            if not lp or not entity.is_alive(lp) then return end

            local doubletap_ref = vars.rage_bot.references.double_tap[1].value and vars.rage_bot.references.double_tap[1].hotkey:get()
            local osaa_ref = vars.rage_bot.references.hide_shots.value and vars.rage_bot.references.hide_shots.hotkey:get()

            local tickbase = globals.tickcount() - entity.get_prop(lp, "m_nTickBase")
            local is_exploiting = osaa_ref or (doubletap_ref and tickbase > 0)
            
            return is_exploiting
        end

        anti_aim.exploit.get_defensive = function()
            if false then
                if true then
                    if anti_aim.exploit.get() then
                        return anti_aim.exploit.breaker.tick
                    else
                        return 1
                    end
                else
                    return anti_aim.exploit.breaker.tick
                end
            else
                if true then
                    if anti_aim.exploit.get() then
                        return (anti_aim.exploit.breaker.tick > 1)
                    else
                        return false
                    end
                else
                    return (anti_aim.exploit.breaker.tick > 1)
                end
            end
        end
    end

    anti_aim.run = function(cmd)
        local lp = entity.get_local_player()
        if lp == nil or not entity.is_alive(lp) then return end

        local is_defensive = anti_aim.exploit.get_defensive() and menu.anti_aim.builder[state_id].defensive_aa.value

        state_id = anti_aim.get_state()

        if menu.anti_aim.builder[state_id].enable_state.value == false and state_id ~= 1 then
            state_id = 1
        end

        anti_aim.data.inverter = anti_aim.get_desync_side(cmd)

        anti_aim.data.delay_value = menu.anti_aim.builder[state_id].jitter_delay.value
            
        if menu.anti_aim.builder[state_id].hold_ticks.value > 1 then
            anti_aim.data.delay_value = globals.tickcount() % 50 > menu.anti_aim.builder[state_id].hold_ticks.value and 1 or menu.anti_aim.builder[state_id].jitter_delay.value
        end

        if menu.anti_aim.builder[state_id].jitter_delay.value > 1 then
            if globals.chokedcommands() == 0 then
                anti_aim.data.ticks = anti_aim.data.ticks + 1

                if anti_aim.data.ticks % (menu.anti_aim.builder[state_id].jitter_delay_randomize.value > 1 and (client.random_int(anti_aim.data.delay_value, menu.anti_aim.builder[state_id].jitter_delay_randomize.value)) or anti_aim.data.delay_value) == 0 then
                    anti_aim.data.ticks = 0
                    anti_aim.data.switch = not anti_aim.data.switch
                end
            end

            anti_aim.data.inverter = anti_aim.data.switch
        end

        if not is_defensive then 
            if cmd.chokedcommands == 0 then
                anti_aim.data.pitch.types = menu.anti_aim.builder[state_id].pitch.value
                anti_aim.data.yaw.type = "180"
        
                local phase_time = math.floor(globals.realtime() * menu.anti_aim.builder[state_id].phase_speed.value) % 3
        
                if menu.anti_aim.builder[state_id].left_right_type.value == "Phases" then
                    if phase_time == 0 then
                        anti_aim.data.add_left_yaw = menu.anti_aim.builder[state_id].yaw_left_phase_1.value
                        anti_aim.data.add_right_yaw = menu.anti_aim.builder[state_id].yaw_right_phase_1.value
                    elseif phase_time == 1 then
                        anti_aim.data.add_left_yaw = menu.anti_aim.builder[state_id].yaw_left_phase_2.value
                        anti_aim.data.add_right_yaw = menu.anti_aim.builder[state_id].yaw_right_phase_2.value
                    elseif phase_time == 2 then
                        anti_aim.data.add_left_yaw = menu.anti_aim.builder[state_id].yaw_left_phase_3.value
                        anti_aim.data.add_right_yaw = menu.anti_aim.builder[state_id].yaw_right_phase_3.value
                    end
                else
                    anti_aim.data.add_left_yaw = menu.anti_aim.builder[state_id].yaw_left.value
                    anti_aim.data.add_right_yaw = menu.anti_aim.builder[state_id].yaw_right.value
                end
                
                anti_aim.data.default_yaw_amount = menu.anti_aim.builder[state_id].yaw_amount.value
        
                if globals.chokedcommands() == 0 then
                    if menu.anti_aim.builder[state_id].add_left_right:get() then
                        anti_aim.data.yaw.degree = (((anti_aim.data.inverter and anti_aim.data.add_left_yaw or anti_aim.data.add_right_yaw) + anti_aim.data.default_yaw_amount) + math.random(0, menu.anti_aim.builder[state_id].yaw_randomize.value / 2))
                    else
                        anti_aim.data.yaw.degree = anti_aim.data.default_yaw_amount
                    end
                
                    if menu.anti_aim.builder[state_id].yaw_jitter.value ~= "Off" then
                        local jitter_amount = menu.anti_aim.builder[state_id].yaw_jitter_amount.value
                        
                        if menu.anti_aim.builder[state_id].yaw_jitter.value == "Center" then
                            anti_aim.data.yaw.degree = anti_aim.data.yaw.degree + (anti_aim.data.inverter and -jitter_amount / 2 or jitter_amount / 2)
                        elseif menu.anti_aim.builder[state_id].yaw_jitter.value == "3-Way" then
                            local tick = globals.tickcount()
                            local period = 10
                            local phase = tick % period
                    
                            local base_shift = anti_aim.data.inverter and (-jitter_amount / 2) or (jitter_amount / 2)
                    
                            if phase < period / 3 then
                                anti_aim.data.yaw.degree = anti_aim.data.yaw.degree - base_shift - math.random(-5, 5)
                            elseif phase < 2 * (period / 3) then
                                anti_aim.data.yaw.degree = anti_aim.data.yaw.degree + base_shift + math.random(-5, 5)
                            else
                                anti_aim.data.yaw.degree = anti_aim.data.yaw.degree + math.random(-3, 3)
                            end
                        else
                            anti_aim.data.yaw.degree = anti_aim.data.yaw.degree + (anti_aim.data.inverter and (-jitter_amount / 2 + math.random(0, 15)) or (jitter_amount / 2 - math.random(0, 15)))
                        end
                    end
                end
        
                if menu.anti_aim.builder[state_id].jitter_delay.value > 1 and menu.anti_aim.builder[state_id].body_yaw:get() == "Jitter" then
                    anti_aim.data.body_yaw.type = "Static"
                                    
                    if globals.chokedcommands() == 0 then
                        anti_aim.data.body_yaw.amount = anti_aim.data.inverter and -1 or 1
                    end
                else
                    anti_aim.data.body_yaw.type = menu.anti_aim.builder[state_id].body_yaw.value
                    anti_aim.data.body_yaw.amount = -1
                end
            end
        else
            if menu.anti_aim.builder[state_id].defensive_pitch.value == "Disabled" then
                anti_aim.data.pitch.types = "Off"
            elseif menu.anti_aim.builder[state_id].defensive_pitch.value == "Down" then
                anti_aim.data.pitch.types = "Down"
            elseif menu.anti_aim.builder[state_id].defensive_pitch.value == "Up" then
                anti_aim.data.pitch.types = "Up"
            elseif menu.anti_aim.builder[state_id].defensive_pitch.value == "Random" then
                anti_aim.data.pitch.types = "Custom"
                anti_aim.data.pitch.custom_amount = client.random_int(menu.anti_aim.builder[state_id].defensive_pitch_random_1.value, menu.anti_aim.builder[state_id].defensive_pitch_random_2.value)
            elseif menu.anti_aim.builder[state_id].defensive_pitch.value == "Sway" then
                local time = 0
                time = time + (menu.anti_aim.builder[state_id].defensive_pitch_sway_speed:get() * 0.5) * globals.curtime()
                local value = math.sin(time) * 89
                
                anti_aim.data.pitch.types = "Custom"
                anti_aim.data.pitch.custom_amount = value
            elseif menu.anti_aim.builder[state_id].defensive_pitch:get() == "Custom" then 
                anti_aim.data.pitch.types = "Custom"
                anti_aim.data.pitch.custom_amount = menu.anti_aim.builder[state_id].defensive_pitch_custom:get()
            end

            if menu.anti_aim.builder[state_id].defensive_yaw.value == "Sideways" then
                anti_aim.data.yaw.degree = anti_aim.data.inverter and -90 or 90
            elseif menu.anti_aim.builder[state_id].defensive_yaw.value == "Side-based" then
                anti_aim.data.yaw.degree = anti_aim.data.inverter and menu.anti_aim.builder[state_id].defensive_yaw_left_yaw.value or menu.anti_aim.builder[state_id].defensive_yaw_right_yaw.value
            elseif menu.anti_aim.builder[state_id].defensive_yaw.value == "Spin" then
                anti_aim.data.yaw.type = "Spin"
                anti_aim.data.yaw.degree = menu.anti_aim.builder[state_id].defensive_yaw_spin_speed.value * 5
            elseif menu.anti_aim.builder[state_id].defensive_yaw.value == "Random" then
                anti_aim.data.yaw.degree = client.random_int(menu.anti_aim.builder[state_id].defensive_yaw_random_1.value, menu.anti_aim.builder[state_id].defensive_yaw_random_2.value)
            elseif menu.anti_aim.builder[state_id].defensive_yaw:get() == "Custom" then
                anti_aim.data.yaw.degree = menu.anti_aim.builder[state_id].defensive_yaw_custom:get()
            end
        end 

        if menu.anti_aim.builder[state_id].defensive_options.value == "Always On" then
            cmd.force_defensive = true
        end

        anti_aim.data.freestanding = menu.anti_aim.freestand_hotkey:get() and true or false
        vars.anti_aim.references.elements.freeStand:set(anti_aim.data.freestanding)

        if anti_aim.data.freestanding then
            vars.anti_aim.references.elements.freeStand:set_hotkey("Always on")
        else
            vars.anti_aim.references.elements.freeStand:set_hotkey("On hotkey")
        end

        if anti_aim.data.manual_yaw_direction ~= 0 then
            vars.anti_aim.references.elements.freeStand:set(false)
        end

        if menu.anti_aim.manual_yaw_right:get() and anti_aim.data.last_pushed_button + 0.2 < globals.curtime() then
            anti_aim.data.manual_yaw_direction = anti_aim.data.manual_yaw_direction == 2 and 0 or 2
            anti_aim.data.last_pushed_button = globals.curtime()
        elseif menu.anti_aim.manual_yaw_left:get() and anti_aim.data.last_pushed_button + 0.2 < globals.curtime() then
            anti_aim.data.manual_yaw_direction = anti_aim.data.manual_yaw_direction == 1 and 0 or 1
            anti_aim.data.last_pushed_button = globals.curtime()
        elseif menu.anti_aim.manual_yaw_forward:get() and anti_aim.data.last_pushed_button + 0.2 < globals.curtime() then
            anti_aim.data.manual_yaw_direction = anti_aim.data.manual_yaw_direction == 3 and 0 or 3
            anti_aim.data.last_pushed_button = globals.curtime()
        elseif anti_aim.data.last_pushed_button > globals.curtime() then
            anti_aim.data.last_pushed_button = globals.curtime()
        end

        if anti_aim.data.manual_yaw_direction == 1 then
            anti_aim.data.yaw.degree = -90
        elseif anti_aim.data.manual_yaw_direction == 2 then
            anti_aim.data.yaw.degree = 90
        elseif anti_aim.data.manual_yaw_direction == 3 then
            anti_aim.data.yaw.degree = -180
        end



        --  @start ~ safe head @_@
        anti_aim.safe_head = { }

        anti_aim.safe_head.run = function(cmd)
            if not menu.anti_aim.tweaks:get("Safe head") then return end

            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end

            local weapon = entity.get_player_weapon(lp)
            if weapon == nil then return end

            local lp_threat = client.current_threat()

            local threat_origin = vector(entity.get_prop(lp_threat, "m_vecOrigin"))
            local lp_origin = vector(entity.get_prop(lp, "m_vecOrigin"))

            local is_knife = entity.get_classname(weapon) == "CKnife"
            local is_taser = entity.get_classname(weapon) == "CWeaponTaser"

            local state_id = anti_aim.get_state()

            local height_difference = lp_origin.z - threat_origin.z > menu.anti_aim.height_difference:get()
            local can_use_above_enemy = (menu.anti_aim.height_difference:get() ~= 0 and not height_difference) and false or true

            local knife_state = menu.anti_aim.safe_head_states:get("Knife") and state_id == 5 and is_knife
            local taser_state = menu.anti_aim.safe_head_states:get("Taser") and state_id == 5 and is_taser
            local above_enemy_state = can_use_above_enemy and menu.anti_aim.safe_head_states:get("Above enemy") and height_difference

            local is_defensive = anti_aim.exploit.get_defensive()

            anti_aim.data.safe_trigger = false

            if knife_state or taser_state or above_enemy_state then
                anti_aim.data.safe_trigger = true

                if menu.anti_aim.e_spam:get() then
                    anti_aim.data.pitch.types = is_defensive and "Up" or "Down"
                    anti_aim.data.pitch.custom_amount = 0
                    anti_aim.data.yaw.base = "At targets"
                    anti_aim.data.yaw.type = "180"
                    anti_aim.data.yaw.degree = is_defensive and 180 or 0
                    anti_aim.data.yaw.jitter.amount = 0
                    anti_aim.data.body_yaw.type = "Static"
                    anti_aim.data.body_yaw.amount = 0
                    anti_aim.data.freestanding = false

                    cmd.force_defensive = true
                else
                    anti_aim.data.pitch.types = "Down"
                    anti_aim.data.pitch.custom_amount = 0
                    anti_aim.data.yaw.base = "At targets"
                    anti_aim.data.yaw.type = "180"
                    anti_aim.data.yaw.degree = 0
                    anti_aim.data.yaw.jitter.amount = 0
                    anti_aim.data.body_yaw.type = "Static"
                    anti_aim.data.body_yaw.amount = 0
                    anti_aim.data.freestanding = false

                    cmd.force_defensive = false
                end
            end
        end

        anti_aim.safe_head.run(cmd)
        --  @end ~ safe head @_@



        --  @start ~ flick exploit K_K
        anti_aim.flick_exploit = { }

        anti_aim.flick_exploit.trigger = false
        anti_aim.flick_exploit.shifting = false
    
        anti_aim.flick_exploit.run = function(cmd)
            anti_aim.flick_exploit.trigger = false
            anti_aim.flick_exploit.shifting = false

            if not menu.anti_aim.tweaks:get("Flick exploit") then return end

            local is_defensive = anti_aim.exploit.get_defensive()
            local slow_motion = vars.anti_aim.references.elements.slow_motion.hotkey:get()
    
            if slow_motion then 
                anti_aim.flick_exploit.trigger = true

                anti_aim.data.pitch.types = "Down"
                anti_aim.data.pitch.custom_amount = 0
                anti_aim.data.yaw.base = "At targets"
                anti_aim.data.yaw.type = "180"

                if is_defensive then
                    anti_aim.flick_exploit.shifting = true

                    if menu.anti_aim.flick_yaw_type:get() == "Switch" then
                        if cmd.command_number % 16 == 0 then
                            anti_aim.data.yaw.degree = menu.anti_aim.flick_yaw_min:get()
                        else
                            anti_aim.data.yaw.degree = menu.anti_aim.flick_yaw_max:get()
                        end
                    else
                        anti_aim.data.yaw.degree = menu.anti_aim.flick_yaw:get()
                    end
                else
                    anti_aim.flick_exploit.shifting = false

                    anti_aim.data.yaw.degree = menu.anti_aim.flick_direction:get()
                end
                
                anti_aim.data.yaw.jitter.amount = 0
                anti_aim.data.body_yaw.type = "Static"
                anti_aim.data.body_yaw.amount = 0

                cmd.force_defensive = cmd.command_number % 8 == 0
            end
        end
    
        anti_aim.flick_exploit.run(cmd)
        --  @end ~ flick exploit K_K



        --  @start ~ fast ladder X_X
        anti_aim.fast_ladder = { }

        anti_aim.fast_ladder.run = function(cmd)
            if not menu.anti_aim.tweaks:get("Fast ladder") then return end
    
            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end
    
            local pitch, yaw = client.camera_angles()

            local move_type = entity.get_prop(lp, "m_MoveType")
            if move_type ~= 9 then return end

            cmd.yaw = math.floor(cmd.yaw + 0.5)
            cmd.roll = 0

            if cmd.forwardmove == 0 then
                if cmd.sidemove ~= 0 then
                    cmd.pitch = 89
                    cmd.yaw = cmd.yaw + 180
                    if cmd.sidemove < 0 then
                        cmd.in_moveleft = 0
                        cmd.in_moveright = 1
                    end
                    if cmd.sidemove > 0 then
                        cmd.in_moveleft = 1
                        cmd.in_moveright = 0
                    end
                end
            end
    
            if cmd.forwardmove > 0 then
                if pitch < 45 then
                    cmd.pitch = 89
                    cmd.in_moveright = 1
                    cmd.in_moveleft = 0
                    cmd.in_forward = 0
                    cmd.in_back = 1
                    if cmd.sidemove == 0 then
                        cmd.yaw = cmd.yaw + 90
                    end
                    if cmd.sidemove < 0 then
                        cmd.yaw = cmd.yaw + 150
                    end
                    if cmd.sidemove > 0 then
                        cmd.yaw = cmd.yaw + 30
                    end
                end 
            end

            if cmd.forwardmove < 0 then
                cmd.pitch = 89
                cmd.in_moveleft = 1
                cmd.in_moveright = 0
                cmd.in_forward = 1
                cmd.in_back = 0

                if cmd.sidemove == 0 then
                    cmd.yaw = cmd.yaw + 90
                end

                if cmd.sidemove > 0 then
                    cmd.yaw = cmd.yaw + 150
                end

                if cmd.sidemove < 0 then
                    cmd.yaw = cmd.yaw + 30
                end
            end
        end
    
        anti_aim.fast_ladder.run(cmd)
        --  @end ~ fast ladder X_X



        --  @start ~ unsafe charge Q_Q
        anti_aim.unsafe_charge = { }

        anti_aim.unsafe_charge.run = function(cmd)
            if not menu.anti_aim.tweaks:get("Unsafe charge") then return end

            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end

            vars.rage_bot.references.enabled:set(true)
            if vars.anti_aim.references.elements.fake_duck:get() then return end

            local weapon = entity.get_player_weapon(lp)
            if weapon == nil then return end

            local next_attack = entity.get_prop(lp, 'm_flNextAttack')

            if next_attack < globals.curtime() then
                if not anti_aim.exploit.charged and (vars.rage_bot.references.double_tap[1].value and vars.rage_bot.references.double_tap[1].hotkey:get()) then
                    vars.rage_bot.references.enabled:set(false)
                else
                    vars.rage_bot.references.enabled:set(true)
                end
            end
        end

        anti_aim.unsafe_charge.run(cmd)
        --  @end ~ unsafe charge Q_Q



        --  @start ~ avoid-backstab stuff #_#
        anti_aim.avoid_backstab = { }

        anti_aim.avoid_backstab.run = function(cmd)
            if not menu.anti_aim.tweaks:get("Avoid backstab") then return end

            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end

            local lp_threat = client.current_threat()
            if lp_threat == nil then return end

            local threat_weapon = entity.get_player_weapon(lp_threat)
            if threat_weapon == nil then return end

            local threat_origin = vector(entity.get_prop(lp_threat, "m_vecOrigin"))

            local lp_origin = vector(entity.get_prop(lp, "m_vecOrigin"))

            local dist = lp_origin:dist(threat_origin)

            local avoid_distance = menu.anti_aim.avoid_backstab_distance:get()

            if dist < avoid_distance and entity.get_classname(threat_weapon) == "CKnife" then
                anti_aim.data.yaw.base = "At targets"
                anti_aim.data.yaw.degree = -180
                anti_aim.data.freestanding = false

                cmd.force_defensive = false
            end
        end

        anti_aim.avoid_backstab.run(cmd)
        --  @end ~ avoid-backstab stuff #_#



        vars.anti_aim.references.elements.pitch[1]:set(anti_aim.data.pitch.types)
        vars.anti_aim.references.elements.pitch[2]:set(anti_aim.data.pitch.custom_amount)
        vars.anti_aim.references.elements.yaw[1]:set(anti_aim.data.yaw.type)
        vars.anti_aim.references.elements.yaw[2]:set(math.normalize_yaw(anti_aim.data.yaw.degree))
        vars.anti_aim.references.elements.yawbase:set(anti_aim.data.yaw.base)
        vars.anti_aim.references.elements.yawjitter[1]:set(anti_aim.data.yaw.jitter.type)
        vars.anti_aim.references.elements.yawjitter[2]:set(anti_aim.data.yaw.jitter.amount)
        vars.anti_aim.references.elements.bodyyaw[1]:set(anti_aim.data.body_yaw.type)
        vars.anti_aim.references.elements.bodyyaw[2]:set(anti_aim.data.body_yaw.amount)
    end
end

local visuals = { } do
    visuals.vars = { } do
        visuals.vars.RGBAtoHEX = function(redArg, greenArg, blueArg, alphaArg)
            return string.format('%.2x%.2x%.2x%.2x', redArg, greenArg, blueArg, alphaArg)
        end
        
        visuals.vars.gradient_text = function(time, string, r, g, b, a, r2, g2, b2, a2)
            local t_out, t_out_iter = {}, 1
        
            local r_add = (r2 - r)
            local g_add = (g2 - g)
            local b_add = (b2 - b)
            local a_add = (a2 - a)
        
            for i = 1, #string do
                local iter = (i - 1)/(#string - 1) + time
                t_out[t_out_iter] = "\a" .. visuals.vars.RGBAtoHEX(r + r_add * math.abs(math.cos(iter)), g + g_add * math.abs(math.cos(iter)), b + b_add * math.abs(math.cos(iter)), a + a_add * math.abs(math.cos(iter)))
        
                t_out[t_out_iter + 1] = string:sub(i, i)
        
                t_out_iter = t_out_iter + 2
            end
        
            return table.concat(t_out)
        end
    
        visuals.vars.rec = function(x, y, w, h, radius, color)
            radius = math.min(x/2, y/2, radius)
            local r, g, b, a = unpack(color)
            renderer.rectangle(x, y + radius, w, h - radius*2, r, g, b, a)
            renderer.rectangle(x + radius, y, w - radius*2, radius, r, g, b, a)
            renderer.rectangle(x + radius, y + h - radius, w - radius*2, radius, r, g, b, a)
            renderer.circle(x + radius, y + radius, r, g, b, a, radius, 180, 0.25)
            renderer.circle(x - radius + w, y + radius, r, g, b, a, radius, 90, 0.25)
            renderer.circle(x - radius + w, y - radius + h, r, g, b, a, radius, 0, 0.25)
            renderer.circle(x + radius, y - radius + h, r, g, b, a, radius, -90, 0.25)
        end
        
        visuals.vars.rec_outline = function(x, y, w, h, radius, thickness, color)
            radius = math.min(w/2, h/2, radius)
            local r, g, b, a = unpack(color)
            if radius == 1 then
                renderer.rectangle(x, y, w, thickness, r, g, b, a)
                renderer.rectangle(x, y + h - thickness, w , thickness, r, g, b, a)
            else
                renderer.rectangle(x + radius, y, w - radius*2, thickness, r, g, b, a)
                renderer.rectangle(x + radius, y + h - thickness, w - radius*2, thickness, r, g, b, a)
                renderer.rectangle(x, y + radius, thickness, h - radius*2, r, g, b, a)
                renderer.rectangle(x + w - thickness, y + radius, thickness, h - radius*2, r, g, b, a)
                renderer.circle_outline(x + radius, y + radius, r, g, b, a, radius, 180, 0.25, thickness)
                renderer.circle_outline(x + radius, y + h - radius, r, g, b, a, radius, 90, 0.25, thickness)
                renderer.circle_outline(x + w - radius, y + radius, r, g, b, a, radius, -90, 0.25, thickness)
                renderer.circle_outline(x + w - radius, y + h - radius, r, g, b, a, radius, 0, 0.25, thickness)
            end
        end
    
        visuals.vars.glow_module = function(x, y, w, h, width, rounding, accent, accent_inner)
            local thickness = 1
            local offset = 1
            local r, g, b, a = unpack(accent)
    
            if accent_inner then
                visuals.vars.rec(x , y, w, h + 1, rounding, accent_inner)
            end
    
            for k = 0, width do
                if a * (k/width)^(1) > 5 then
                    local accent = {r, g, b, a * (k/width)^(2)}
    
                    visuals.vars.rec_outline(x + (k - width - offset)*thickness, y + (k - width - offset) * thickness, w - (k - width - offset)*thickness*2, h + 1 - (k - width - offset)*thickness*2, rounding + thickness * (width - k + offset), thickness, accent)
                end
            end
        end
    end

    visuals.watermark = { } do
        visuals.watermark.paint = function()
            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end
    
            local watermark_color_r, watermark_color_g, watermark_color_b = menu.other.visuals.watermark_color:get()

            if not menu.other.visuals.watermark:get() then
                renderer.text(screen_x / 2, screen_y - 22, 255, 255, 255, 255, "c", 0, "debug")
                renderer.text(screen_x / 2, screen_y - 10, 255, 255, 255, 255, "c", 0, visuals.vars.gradient_text(globals.curtime() * -2, "N Y A H O O K", watermark_color_r, watermark_color_g, watermark_color_b, 255, 100, 100, 100, 255))
            else
                if menu.other.visuals.watermark:get() then
                    if menu.other.visuals.watermark_style:get() == "Modern" then
                        renderer.rectangle(10, screen_y / 2 + 20, 80, 85, 10, 10, 10, 255 * 0.7)
                        renderer.rectangle(10, screen_y / 2 + 20, 80, 1, watermark_color_r, watermark_color_g, watermark_color_b, 255)

                        renderer.rectangle(15, screen_y / 2 + 40, 70, 1, watermark_color_r, watermark_color_g, watermark_color_b, 150)

                        renderer.gradient(10, screen_y / 2 + 20, 1, 20, watermark_color_r, watermark_color_g, watermark_color_b, 255, watermark_color_r, watermark_color_g, watermark_color_b, 0, false)
                        renderer.gradient(90, screen_y / 2 + 20, 1, 20, watermark_color_r, watermark_color_g, watermark_color_b, 255, watermark_color_r, watermark_color_g, watermark_color_b, 0, false)
                        
                        renderer.rectangle(10, screen_y / 2 + 104, 80, 1, watermark_color_r, watermark_color_g, watermark_color_b, 255)

                        renderer.gradient(10, screen_y / 2 + 85, 1, 20, watermark_color_r, watermark_color_g, watermark_color_b, 0, watermark_color_r, watermark_color_g, watermark_color_b, 255, false)
                        renderer.gradient(90, screen_y / 2 + 85, 1, 20, watermark_color_r, watermark_color_g, watermark_color_b, 0, watermark_color_r, watermark_color_g, watermark_color_b, 255, false)

                        local inverter = anti_aim.data.inverter and "+" or "-"
                        local direction = anti_aim.data.manual_yaw_direction ~= 0 and (anti_aim.data.manual_yaw_direction == 1 and "<" or anti_aim.data.manual_yaw_direction == 2 and ">" or "FRONT") or "AUTO"
                        local safe = anti_aim.data.safe_trigger and "ACTIVE" or "NONE"

                        local state_id = anti_aim.get_state()

                        renderer.text(48, screen_y / 2 + 30, 255, 255, 255, 255, "-c", 0, "NYAHOOK | DEBUG")
                        renderer.text(17, screen_y / 2 + 45, 255, 255, 255, 255, "-", 0, "MODE: \a" .. visuals.vars.RGBAtoHEX(watermark_color_r, watermark_color_g, watermark_color_b, 255)  .. "GOD")
                        renderer.text(17, screen_y / 2 + 55, 255, 255, 255, 255, "-", 0, "INVERTER: \a" .. visuals.vars.RGBAtoHEX(watermark_color_r, watermark_color_g, watermark_color_b, 255)  .. inverter)
                        renderer.text(17, screen_y / 2 + 65, 255, 255, 255, 255, "-", 0, "DIRECTION: \a" .. visuals.vars.RGBAtoHEX(watermark_color_r, watermark_color_g, watermark_color_b, 255)  .. direction)
                        renderer.text(17, screen_y / 2 + 75, 255, 255, 255, 255, "-", 0, "SAFE: \a" .. visuals.vars.RGBAtoHEX(watermark_color_r, watermark_color_g, watermark_color_b, 255)  .. safe)
                        renderer.text(17, screen_y / 2 + 85, 255, 255, 255, 255, "-", 0, "STATE: \a" .. visuals.vars.RGBAtoHEX(watermark_color_r, watermark_color_g, watermark_color_b, 255) .. state_id)
                    else
                        renderer.text(10, screen_y / 2 + 5, 255, 255, 255, 255, "", 0, "nyahook ~ \a" .. visuals.vars.RGBAtoHEX(watermark_color_r, watermark_color_g, watermark_color_b, 255) .. "debug\aFFFFFFFF | user: \a" .. visuals.vars.RGBAtoHEX(watermark_color_r, watermark_color_g, watermark_color_b, 255) .. "admin")
                    end
                end
            end
        end
    end

    visuals.exploit_indication = { } do
        visuals.exploit_indication.paint = function()
            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end

            if not menu.other.visuals.exploit_indication:get() then return end

            local is_defensive = anti_aim.exploit.get_defensive()
            local charged = anti_aim.exploit.charged

            local animated_defensive = animations.new("animated_defensive", (not is_defensive and anti_aim.exploit.charged) and ((is_defensive and anti_aim.exploit.charged) and 1 or (anti_aim.exploit.charged and 1 or 0)) or 0, 0.07)
            local animated_charged = animations.new("animated_charged", charged and 1 or 0, 0.07)

            local animated_is_defensive = animations.new("animated_is_defensive", is_defensive and 1 or 0, 0.2)

            local defensive_state = is_defensive and "true" or "false"

            local masure_defensive = renderer.measure_text("", "forcing defensive: ")

            local exploit_indication_color_r, exploit_indication_color_g, exploit_indication_color_b = menu.other.visuals.exploit_indication_color:get()

            renderer.rectangle(screen_x - 120, 5, 115, 25, 10, 10, 10, (255 * 0.7) * animated_charged)
            renderer.text(screen_x - 115, 11, 255, 255, 255, 255 * animated_charged, "b", 0, "EX")
            renderer.text(screen_x - 120, 32, 255, 255, 255, (255 * 0.5) * animated_charged, "", 0, "forcing defensive: ")
            renderer.text(screen_x - 120 + masure_defensive, 32 + (2 * animated_is_defensive), 255, 255, 255, (255 * 0.5) * animated_charged, "", 0, defensive_state)

            visuals.vars.rec(screen_x - 95, 15, 5 + (80 * animated_defensive), 6, 3, { exploit_indication_color_r, exploit_indication_color_g, exploit_indication_color_b, 255 * animated_charged })

            renderer.rectangle(screen_x - 120, 5, 115, 1, exploit_indication_color_r, exploit_indication_color_g, exploit_indication_color_b, 255 * animated_charged)

            renderer.gradient(screen_x - 120, 5, 1, 28, exploit_indication_color_r, exploit_indication_color_g, exploit_indication_color_b, 255 * animated_charged, exploit_indication_color_r, exploit_indication_color_g, exploit_indication_color_b, 0, false)
            renderer.gradient(screen_x - 5, 5, 1, 28, exploit_indication_color_r, exploit_indication_color_g, exploit_indication_color_b, 255 * animated_charged, exploit_indication_color_r, exploit_indication_color_g, exploit_indication_color_b, 0, false)
        end
    end

    visuals.damage_indicator = { } do
        visuals.damage_indicator.paint = function()
            if not menu.other.visuals.damage_indicator:get() then return end
    
            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end
    
            local damage = vars.rage_bot.references.minimum_damage_override[1].hotkey:get() and vars.rage_bot.references.minimum_damage_override[2]:get() or vars.rage_bot.references.minimum_damage[1]:get()
    
            renderer.text(screen_x / 2 + 5, screen_y / 2 - 15, 255, 255, 255, 255, nil, 0, damage)
        end
    end

    visuals.cross_marker = { } do
        visuals.cross_marker.queue = { }

        visuals.cross_marker.aim_fire = function(c)
            visuals.cross_marker.queue[globals.tickcount()] = {c.x,c.y,c.z, globals.curtime() + 2}
        end
    
        visuals.cross_marker.paint = function(c)
            if not menu.other.visuals.cross_marker:get() then return end
    
            for tick, data in pairs(visuals.cross_marker.queue) do
                if globals.curtime() <= data[4] then
                    local screen_x, screen_y = renderer.world_to_screen(data[1], data[2], data[3])
                    
                    if screen_x ~= nil and screen_y ~= nil then
                        renderer.line(screen_x - 4 * 2, screen_y - 4 * 2, screen_x - ( 4 ), screen_y - ( 4 ), 255, 255, 255, 255)
                        renderer.line(screen_x - 4 * 2, screen_y + 4 * 2, screen_x - ( 4 ), screen_y + ( 4 ), 255, 255, 255, 255)
                        renderer.line(screen_x + 4 * 2, screen_y + 4 * 2, screen_x + ( 4 ), screen_y + ( 4 ), 255, 255, 255, 255)
                        renderer.line(screen_x + 4 * 2, screen_y - 4 * 2, screen_x + ( 4 ), screen_y - ( 4 ), 255, 255, 255, 255)
                    end
                end
            end
        end
    end

    visuals.manual_arrows = { } do
        visuals.manual_arrows.paint = function(c)
            if not menu.other.visuals.manual_arrows:get() then return end

            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end

            local arrows_r, arrows_g, arrows_b = menu.other.visuals.manual_arrows_color:get()

            local alpha = animations.new("manual_alpha", anti_aim.data.manual_yaw_direction ~= 0 and 1 or 0, 0.1)

            local main_color = { arrows_r, arrows_g, arrows_b, 255 * alpha }
            local disabled_color = { 255, 255, 255, 255 * alpha }

            local arrows_color_left = anti_aim.data.manual_yaw_direction == 1 and main_color or disabled_color
            local arrows_color_right = anti_aim.data.manual_yaw_direction == 2 and main_color or disabled_color
            local arrows_color_down = anti_aim.data.manual_yaw_direction ~= 0 and disabled_color or main_color

            local classic_style = menu.other.visuals.manual_arrows_style:get() == "Classic"
            local measure_arrow = renderer.measure_text(classic_style and "+" or "", classic_style and ">" or "❱")

            renderer.text(screen_x / 2 + 45, screen_y / 2 - (classic_style and 16 or 7), arrows_color_right[1], arrows_color_right[2], arrows_color_right[3], arrows_color_right[4], classic_style and "+" or "", 0, classic_style and ">" or "❱")
            renderer.text(screen_x / 2 - measure_arrow - 45, screen_y / 2 - (classic_style and 16 or 7), arrows_color_left[1], arrows_color_left[2], arrows_color_left[3], arrows_color_left[4], classic_style and "+" or "", 0, classic_style and "<" or "❰")
        end 
    end

    visuals.custom_scope_overlay = { } do
        visuals.custom_scope_overlay.paint = function()
            if not menu.other.visuals.custom_scope_overlay:get() then return end

            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end

            vars.visuals.references.scope_overlay:override(false)

            local scoped = entity.get_prop(lp, "m_bIsScoped") == 1

            local scope_r, scope_g, scope_b = menu.other.visuals.custom_scope_overlay_color:get()

            local gap = menu.other.visuals.custom_scope_overlay_gap:get()
            local size = menu.other.visuals.custom_scope_overlay_size:get()

            local gap_sm = animations.new("smoothy_shit_gap", scoped and menu.other.visuals.custom_scope_overlay_gap:get() or 0, 0.1)
            local size_sm = animations.new("smoothy_shit_size", scoped and menu.other.visuals.custom_scope_overlay_size:get() or 0, 0.1)

            renderer.gradient(screen_x / 2, screen_y / 2 + gap_sm, 1, size_sm, scope_r, scope_g, scope_b, 255, scope_r, scope_g, scope_b, 0, false)
            renderer.gradient(screen_x / 2, screen_y / 2 - gap_sm, 1, -size_sm, scope_r, scope_g, scope_b, 255, scope_r, scope_g, scope_b, 0, false)

            renderer.gradient(screen_x / 2 + gap_sm, screen_y / 2, size_sm, 1, scope_r, scope_g, scope_b, 255, scope_r, scope_g, scope_b, 0, true)
            renderer.gradient(screen_x / 2 - gap_sm, screen_y / 2, -size_sm, 1, scope_r, scope_g, scope_b, 255, scope_r, scope_g, scope_b, 0, true)
        end
    end

    visuals.animated_zoom = { } do
        visuals.animated_zoom.run = function(e)
            local lp = entity.get_local_player()
            if lp == nil or not entity.is_alive(lp) then return end
        
            local weapon = entity.get_player_weapon(lp)
            if weapon == nil then return end
        
            local zoom_level = entity.get_prop(weapon, "m_zoomLevel")
            local scoped = entity.get_prop(lp, "m_bIsScoped") == 1
    
            local zoom_fov = 0
    
            if not menu.other.visuals.animated_zoom:get() then return end
        
            if scoped then
                if zoom_level == 1 then
                    zoom_fov = menu.other.visuals.animated_zoom_fov:get()
                elseif zoom_level == 2 then
                    zoom_fov = menu.other.visuals.animated_zoom_second_fov:get()
                end
            end
        
            local animated_fov = animations.new("animated_fov", vars.misc.references.override_fov:get() - zoom_fov)
    
            e.fov = animated_fov
        end
    end

    visuals.aspect_ratio = { } do
        visuals.aspect_ratio.run = function()
            if menu.other.visuals.aspect_ratio:get() then
                client.set_cvar("r_aspectratio", menu.other.visuals.aspect_ratio_value:get() / 100)
            else
                client.set_cvar("r_aspectratio", 0)
            end
        end
    end
end

local misc = { } do
    misc.aimbot_logs = { } do
        misc.aimbot_logs.print_log = function(text)
            client.color_log(255, 255, 255, "[\0")
            client.color_log(211, 160, 187, "Nya\0")
            client.color_log(255, 255, 255, "Hook] \0")
            client.color_log(255, 255, 255, text)
        end

        misc.aimbot_logs.notify_data = { }

        misc.aimbot_logs.notifications = function()
            for i, logs in ipairs(misc.aimbot_logs.notify_data) do
                if logs.time + 1 > globals.realtime() and i <= 5 then
                    logs.alpha = animations.lerp(logs.alpha, 255, 0.05)
                    logs.alpha_text = animations.lerp(logs.alpha_text, 255, 0.05)
                    logs.add_x = animations.lerp(logs.add_x, 1, 0.05)
                end

                local string = tostring(logs.text)

                local size = renderer.measure_text("", string)

                local rect_size = size / 2 + 20
    
                if logs.alpha <= 0 then
                    logs[i] = nil
                else
                    logs.add_y = animations.lerp(logs.add_y, i * 40, 0.05)

                    visuals.vars.rec(screen_x / 2 - rect_size, screen_y - 68 - logs.add_y, 30, 25, 0, { 15, 15, 15, logs.alpha * 0.7 })
                    visuals.vars.rec(screen_x / 2 + rect_size - size, screen_y - 68 - logs.add_y, size + 10, 25, 0, { 15, 15, 15, logs.alpha * 0.7 })

                    renderer.gradient(screen_x / 2 - rect_size, screen_y - 69 - logs.add_y, 1, 25, logs.color[1], logs.color[2], logs.color[3], logs.alpha, logs.color[1], logs.color[2], logs.color[3], logs.alpha * 0, false)
                    renderer.gradient(screen_x / 2 - rect_size + 30, screen_y - 69 - logs.add_y, 1, 25, logs.color[1], logs.color[2], logs.color[3], logs.alpha, logs.color[1], logs.color[2], logs.color[3], logs.alpha * 0, false)

                    renderer.gradient(screen_x / 2 - size / 2 + 20, screen_y - 69 - logs.add_y, 1, 25, logs.color[1], logs.color[2], logs.color[3], logs.alpha, logs.color[1], logs.color[2], logs.color[3], logs.alpha * 0, false)
                    renderer.gradient(screen_x / 2 + rect_size + 10, screen_y - 69 - logs.add_y, 1, 25, logs.color[1], logs.color[2], logs.color[3], logs.alpha, logs.color[1], logs.color[2], logs.color[3], logs.alpha * 0, false)

                    visuals.vars.rec(screen_x / 2 - rect_size, screen_y - 69 - logs.add_y, 30, 1, 0, { logs.color[1], logs.color[2], logs.color[3], logs.alpha })
                    visuals.vars.rec(screen_x / 2 + rect_size - size, screen_y - 69 - logs.add_y, size + 10, 1, 0, { logs.color[1], logs.color[2], logs.color[3], logs.alpha })

                    renderer.text(screen_x / 2 - size / 2 - 5, screen_y - 56 - logs.add_y, logs.color[1], logs.color[2], logs.color[3], logs.alpha_text, "c", 0, "N")
                    renderer.text(screen_x / 2 + rect_size - size / 2 + 5, screen_y - 56 - logs.add_y, 255, 255, 255, logs.alpha_text, "c", 0, logs.text)

                    if logs.time + 3 < globals.realtime() or i > 5 then
                        logs.alpha = animations.lerp(logs.alpha, 0, 0.05)
                        logs.alpha_text = animations.lerp(logs.alpha_text, 0, 0.05)
                        logs.add_x = animations.lerp(logs.add_x, 0, 0.05)
                        logs.add_y = animations.lerp(logs.add_y, i * 60, 0.05)
                    end
                end
    
                if logs.alpha < 1 then
                    table.remove(misc.aimbot_logs.notify_data, i)
                end
            end
        end

        misc.aimbot_logs.hitgroup = {'generic', 'head', 'chest', 'stomach', 'left arm', 'right arm', 'left leg', 'right leg', 'neck', '?', 'gear'}

        misc.aimbot_logs.fire_data = { }

        misc.aimbot_logs.aim_fire = function(c)
            misc.aimbot_logs.fire_data.damage = c.damage
            misc.aimbot_logs.fire_data.hitgroup = misc.aimbot_logs.hitgroup[c.hitgroup + 1] or "?"
            misc.aimbot_logs.fire_data.hitchance = math.floor(c.hit_chance)
        end
        
        misc.aimbot_logs.hit = { } do
            misc.aimbot_logs.hit.aim_hit = function(c)
                if not menu.other.misc.aimbot_logs:get() then return end

                local target = entity.get_player_name(c.target)
                local hitgroup = misc.aimbot_logs.hitgroup[c.hitgroup + 1] or '?'
                local damage = c.damage

                misc.aimbot_logs.print_log(string.format("Hit %s in the %s(%s) for %s(%s) damage [ hitchance: %s%% | history: %s ]", target, hitgroup, misc.aimbot_logs.fire_data.hitgroup, damage, misc.aimbot_logs.fire_data.damage, misc.aimbot_logs.fire_data.hitchance, globals.tickcount() - c.tick))
                
                local r, g, b, a = menu.other.misc.hit_color:get()
                
                if menu.other.misc.notify_output:get() then
                    table.insert(misc.aimbot_logs.notify_data, 1, {
                        text = string.format("Hit %s in the %s for %s damage", target, hitgroup, damage), 
                        alpha = 0, alpha_text = 0, add_x = 0, add_y = 0, time = globals.realtime(), color = { r, g, b, a }})
                else
                    misc.aimbot_logs.notify_data = { }
                end
            end
        end

        misc.aimbot_logs.miss = { } do
            misc.aimbot_logs.hit.aim_miss = function(c)
                if not menu.other.misc.aimbot_logs:get() then return end

                local target = entity.get_player_name(c.target)
                local hitchance = math.floor(c.hit_chance)
                local hitgroup = misc.aimbot_logs.hitgroup[c.hitgroup + 1] or '?'
                local reason = c.reason

                misc.aimbot_logs.print_log(string.format("Missed shot due to %s at %s in the %s for %s damage [ hitchance: %s%% | history: %s ]", reason, target, hitgroup, misc.aimbot_logs.fire_data.damage, hitchance, globals.tickcount() - c.tick))
            
                local r, g, b, a = menu.other.misc.miss_color:get()

                if menu.other.misc.notify_output:get() then
                    table.insert(misc.aimbot_logs.notify_data, 1, {
                        text = string.format("Missed shot due to %s at %s in the %s for %s damage", reason, target, hitgroup, misc.aimbot_logs.fire_data.damage), 
                        alpha = 0, alpha_text = 0, add_x = 0, add_y = 0, time = globals.realtime(), color = { r, g, b, a }})
                else
                    misc.aimbot_logs.notify_data = { }
                end
            end
        end
    end

    misc.animations = { } do
        misc.animations.pose_parameters = {
            STRAFE_YAW = 0,
            STAND = 1,
            LEAN_YAW = 2,
            SPEED = 3,
            LADDER_YAW = 4,
            LADDER_SPEED = 5,
            JUMP_FALL = 6,
            MOVE_YAW = 7,
            MOVE_BLEND_CROUCH = 8,
            MOVE_BLEND_WALK = 9,
            MOVE_BLEND_RUN = 10,
            BODY_YAW = 11,
            BODY_PITCH = 12,
            AIM_BLEND_STAND_IDLE = 13,
            AIM_BLEND_STAND_WALK = 14,
            AIM_BLEND_STAND_RUN = 14,
            AIM_BLEND_CROUCH_IDLE = 16,
            AIM_BLEND_CROUCH_WALK = 17,
            DEATH_YAW = 18
        }

        misc.animations.pre_render = function()
            if not menu.other.misc.animations:get() then return end

            local lp = entity.get_local_player()
            if not lp or not entity.is_alive(lp) then return end

            local state_id = anti_aim.get_state()
        
            local self_index = c_entity.new(lp)
            
            local self_anim_state = self_index:get_anim_state()
            if not self_anim_state then return end

            if menu.other.misc.ground_legs:get() == "Walking" then
                vars.anti_aim.references.elements.other.leg_movement:set("Never slide")
            elseif menu.other.misc.ground_legs:get() == "Jitter" then
                vars.anti_aim.references.elements.other.leg_movement:set(globals.tickcount() % 4 > 1 and "Off" or "Always slide")
                
                if menu.other.misc.ground_legs_type:get() == "Full" then
                    entity.set_prop(lp, "m_flPoseParameter", globals.tickcount() % 4 > 1 and 1 or 0.5, misc.animations.pose_parameters.STRAFE_YAW)
                elseif menu.other.misc.ground_legs_type:get() == "Randomized" then
                    entity.set_prop(lp, "m_flPoseParameter", client.random_float(0.1, 1), misc.animations.pose_parameters.STRAFE_YAW)
                else
                    entity.set_prop(lp, "m_flPoseParameter", globals.tickcount() % client.random_float(3, 5) > 1 and client.random_float(0.5, 0.8) or 0, misc.animations.pose_parameters.STRAFE_YAW)
                end
            elseif menu.other.misc.ground_legs:get() == "Moonwalk" then
                vars.anti_aim.references.elements.other.leg_movement:set("Never slide")
                entity.set_prop(lp, "m_flPoseParameter", 0.5, 7)
            end

            if menu.other.misc.air_legs:get() == "Static" then
                entity.set_prop(lp, "m_flPoseParameter", 1, misc.animations.pose_parameters.JUMP_FALL)
            elseif menu.other.misc.air_legs:get() == "Jitter" then
                entity.set_prop(lp, "m_flPoseParameter", globals.tickcount() % 4 > 1 and 1 or 0, misc.animations.pose_parameters.JUMP_FALL)
            elseif menu.other.misc.air_legs:get() == "Moonwalk" then
                local self_anim_overlay = self_index:get_anim_overlay(6)
                if not self_anim_overlay then return end

                local x_velocity = entity.get_prop(lp, "m_vecVelocity[0]")

                if math.abs(x_velocity) >= 3 then
                    self_anim_overlay.weight = 1
                end
            else
                entity.set_prop(lp, "m_flPoseParameter", 0, misc.animations.pose_parameters.JUMP_FALL)
            end
            
            if menu.other.misc.addons:get("Body Lean") then
                local self_anim_overlay = self_index:get_anim_overlay(12)
                if not self_anim_overlay then return end
        
                local x_velocity = entity.get_prop(lp, "m_vecVelocity[0]")

                if math.abs(x_velocity) >= 3 then
                    self_anim_overlay.weight = 1
                end
            end

            if menu.other.misc.addons:get("Earthquake") then
                local self_anim_overlay = self_index:get_anim_overlay(12)
                if not self_anim_overlay then return end
        
                self_anim_overlay.weight = client.random_float(0, 1)
            end
        
            if menu.other.misc.addons:get("Pitch 0 on land") then
                if not self_anim_state.hit_in_ground_animation then return end

                entity.set_prop(lp, "m_flPoseParameter", 0.5, misc.animations.pose_parameters.BODY_PITCH)
            end 
        end
    end

    misc.console_filter = { } do
        menu.other.misc.console_filter:set_callback(function(self)
            if self:get() then
                cvar.developer:set_int(0)
                cvar.con_filter_enable:set_int(1)
                cvar.con_filter_text:set_string("IrWL5106TZZKNFPz4P4Gl3pSN?J370f5hi373ZjPg%VOVh6lN")
                client.exec("con_filter_enable 1")
            else
                cvar.con_filter_enable:set_int(0)
                cvar.con_filter_text:set_string("")
                client.exec("con_filter_enable 0")
            end
        end)
        
        events.shutdown:set(function()
            cvar.con_filter_enable:set_int(0)
            cvar.con_filter_text:set_string("")
            client.exec("con_filter_enable 0")
        end)
    end

    misc.aim_tools = { } do
        misc.aim_tools.correction = { } do
            --------------------------------------------------
            -- Helper: Convert an entity's vector property into a table with x, y, z keys.
            --------------------------------------------------
            function get_vector(ent, prop)
                return {
                    x = entity.get_prop(ent, prop, 0),  -- x component
                    y = entity.get_prop(ent, prop, 1),  -- y component
                    z = entity.get_prop(ent, prop, 2)   -- z component
                }
            end
        
            --------------------------------------------------
            -- Helper: Calculate horizontal angle between two vectors.
            -- Returns an angle in degrees in the range [0, 360).
            --------------------------------------------------
            function calculate_angle(src, dst)
                local dx = dst.x - src.x
                local dy = dst.y - src.y
                local angle = math.deg(math.atan2(dy, dx))
                if angle < 0 then
                    angle = angle + 360
                end
                return angle
            end
        
            --------------------------------------------------
            -- (1) Get the player's animation state.
            --------------------------------------------------
            misc.aim_tools.correction.get_anim_state = function(player)
                if not player then return nil end
                local player_ptr = ffi.cast("void***", get_client_entity(ientitylist, player))
                local animstate_ptr = ffi.cast("char*", player_ptr) + 0x9960
                return ffi.cast("struct c_animstate**", animstate_ptr)[0]
            end
        
            --------------------------------------------------
            -- (2) History Storage
            --
            -- Stores previous goal angles and extensive history 
            -- records (current, previous, pre-previous, etc.) to 
            -- support multi-frame correction.
            --------------------------------------------------
            misc.aim_tools.correction.old_goal_feet_yaw = {}    -- last frame goal_feet_yaw
            misc.aim_tools.correction.current_goal_feet_yaw = {}  -- current frame goal_feet_yaw
            misc.aim_tools.correction.history = {}               -- extended historical data
        
            --------------------------------------------------
            -- (3) Update History Record for a Player
            --
            -- This function gathers important data from the player's
            -- current state (simulation time, yaw, stance, shot timing)
            -- and updates a multi-level history record.
            --------------------------------------------------
            misc.aim_tools.correction.update_record = function(player)
                local simtime = entity.get_prop(player, "m_flSimulationTime")
                if not simtime then return end
        
                if not misc.aim_tools.correction.history[player] then
                    misc.aim_tools.correction.history[player] = {
                        cur = nil,
                        prev = nil,
                        pre_prev = nil,
                        pre_pre_prev = nil,
                    }
                end
                local hist = misc.aim_tools.correction.history[player]
        
                -- Update if no record exists or at least 1 second passed since last record.
                if not hist.cur or (simtime - hist.cur.simtime >= 1) then
                    local new_record = {}
                    new_record.id = player
                    new_record.origin = get_vector(player, "m_vecOrigin")
        
                    local eye_angles = {
                        pitch = entity.get_prop(player, "m_angEyeAngles[0]"),
                        yaw = entity.get_prop(player, "m_angEyeAngles[1]")
                    }
                    new_record.pitch = eye_angles.pitch
        
                    -- Calculate an absolute yaw relative to a "shooter" (local player) position.
                    local local_player = entity.get_local_player()
                    local shooter_origin = get_vector(local_player, "m_vecOrigin")
                    local calculated_angle = calculate_angle(shooter_origin, new_record.origin)
                    new_record.yaw = math.floor(eye_angles.yaw - calculated_angle)
                    new_record.yaw_backwards = math.floor((eye_angles.yaw - 180) - calculated_angle)
                    new_record.simtime = simtime
        
                    -- Determine stance: running, standing, duck, or in air.
                    local flags = entity.get_prop(player, "m_fFlags")
                    local on_ground = flags and (bit.band(flags, 1) ~= 0)
                    local ducking = entity.get_prop(player, "m_bDucking")
                    if on_ground then
                        local vel_x, vel_y = entity.get_prop(player, "m_vecVelocity")
                        local speed = math.sqrt(vel_x * vel_x + vel_y * vel_y)
                        new_record.stance = (speed > 0.1) and "running" or "standing"
                    elseif ducking then
                        new_record.stance = "duck"
                    else
                        new_record.stance = "in air"
                    end
        
                    new_record.esp_flags = 0  -- placeholder
        
                    -- Handle recent shot data.
                    new_record.last_shot_time = entity.get_prop(player, "m_flLastShotTime") or 0
                    local tick_interval = globals.tickinterval()
                    local shot_threshold = math.floor(0.2 / tick_interval)
                    local current_tick = globals.tickcount()
                    if new_record.last_shot_time > 0 then
                        local last_shot_tick = math.floor(new_record.last_shot_time / tick_interval)
                        new_record.recent_shot = ((current_tick - last_shot_tick) < shot_threshold)
                    else
                        new_record.recent_shot = false
                    end
        
                    -- Compute yaw differences relative to the current record.
                    if hist.cur then
                        local diff = math.normalize_yaw(new_record.yaw - hist.cur.yaw)
                        new_record.yaw_diff = math.abs(diff)
                        new_record.signed_yaw_diff = diff
                    else
                        new_record.yaw_diff = 0
                        new_record.signed_yaw_diff = 0
                    end
        
                    -- Shift history records: the oldest drops off.
                    hist.pre_pre_prev = hist.pre_prev
                    hist.pre_prev = hist.prev
                    hist.prev = hist.cur
                    hist.cur = new_record
                end
            end
        
            --------------------------------------------------
            -- (4) Heavily Enhanced predict_yaw Function
            --
            -- Uses multi-frame history to compute a weighted average
            -- of yaw differences over the last few records. If a 
            -- recent shot is detected, applies an extra offset.
            --------------------------------------------------
            misc.aim_tools.correction.predict_yaw = function(player, current_goal)
                local hist = misc.aim_tools.correction.history[player]
                if hist and hist.cur and hist.prev then
                    local diff1 = math.normalize_yaw(hist.cur.yaw - hist.prev.yaw)
                    local diff2 = 0
                    if hist.pre_prev then
                        diff2 = math.normalize_yaw(hist.prev.yaw - hist.pre_prev.yaw)
                    end
        
                    local weighted_diff = (diff1 * 0.7 + diff2 * 0.3)
                    local prediction_factor = 1.5
                    local predicted_yaw = current_goal + prediction_factor * weighted_diff
                    if hist.cur.recent_shot then
                        predicted_yaw = predicted_yaw + 5
                    end
                    return math.normalize_yaw(predicted_yaw)
                else
                    return math.normalize_yaw(current_goal)
                end
            end
        
            --------------------------------------------------
            -- (5) Fully Reworked correct_angle Function
            --
            -- Combines updated history, enhanced yaw prediction, and
            -- inline jitter correction.
            --
            -- The jitter logic no longer uses a sine-based offset.
            -- Instead, it computes a dynamic offset based on the delta 
            -- between the current and previous yaw values if that delta 
            -- exceeds a threshold. This offset is scaled by a configurable 
            -- factor and reduced if a recent shot occurred.
            --------------------------------------------------
            misc.aim_tools.correction.correct_angle = function(player)
                -- Early validity and state checks.
                if not player then return end
                if not menu.other.misc.aim_tools:get() then return end
                if not menu.other.misc.jitter_correction:get() then return end
                if entity.is_dormant(player) or not entity.is_alive(player) then return end
            
                -- Update the player's history so we have the freshest yaw, shot, and stance data.
                misc.aim_tools.correction.update_record(player)
                local hist = misc.aim_tools.correction.history[player]
                if not hist or not hist.cur then return end
            
                -- Retrieve the player's animation state to obtain the current goal yaw.
                local animstate = misc.aim_tools.correction.get_anim_state(player)
                if not animstate or not animstate.m_flGoalFeetYaw then return end
                local current_goal = animstate.m_flGoalFeetYaw
            
                -- Maintain an "old" goal (from the previous frame) if not already stored.
                misc.aim_tools.correction.old_goal_feet_yaw[player] = misc.aim_tools.correction.old_goal_feet_yaw[player] or current_goal
                local old_goal = misc.aim_tools.correction.old_goal_feet_yaw[player]
                misc.aim_tools.correction.current_goal_feet_yaw[player] = current_goal
            
                -- Use the enhanced, history-based predict_yaw function.
                local predicted_yaw = misc.aim_tools.correction.predict_yaw(player, current_goal)
            
                -- Retrieve the body orientation from the pose parameter (translating it to degrees).
                local body_pose = entity.get_prop(player, "m_flPoseParameter", 11) * 120 - 60
                -- (Synchronize eye yaw with body pose – useful for debugging or internal use.)
                entity.set_prop(player, "m_angEyeAngles[1]", body_pose)
            
                -- Base correction is the normalized difference between the predicted yaw and the current body orientation.
                local base_correction = math.normalize_yaw(predicted_yaw - body_pose)
            
                -- New Jitter Correction Logic:
                --
                -- Instead of a sine-based offset, we use the yaw delta between consecutive history records.
                -- Also incorporate the change in prediction relative to the previously stored goal.
                local yaw_delta, predictive_delta = 0, 0
                if hist.cur and hist.prev then
                    yaw_delta = math.normalize_yaw(hist.cur.yaw - hist.prev.yaw)
                    predictive_delta = math.normalize_yaw(predicted_yaw - old_goal)
                end
            
                -- If the absolute change in yaw (delta) is above a threshold, compute a correction.
                local jitter_threshold = (menu.other.misc.jitter_threshold and menu.other.misc.jitter_threshold:get()) or 2  -- default threshold in degrees.
                local jitter_factor = (menu.other.misc.jitter_factor and menu.other.misc.jitter_factor:get()) or 0.5  -- default scaling factor.
                local jitter_correction = 0
                if math.abs(yaw_delta) > jitter_threshold then
                    -- Combine the immediate delta and part of the predictive change.
                    jitter_correction = yaw_delta * jitter_factor + predictive_delta * 0.3
                end
            
                -- If a recent shot event occurred, reduce the applied jitter to soften the correction.
                if hist.cur.recent_shot then
                    jitter_correction = jitter_correction * 0.5
                end
            
                -- Combine the base correction with the dynamic jitter correction.
                local combined_correction = base_correction + jitter_correction
            
                -- Normalize and clamp the final correction to a safe range (–60° to 60°).
                local final_correction = math.normalize_yaw(math.clamp(combined_correction, -60, 60))
            
                -- If debug mode is enabled, output detailed intermediary values.
                if menu.other.misc.jitter_correction_debug:get() then
                    renderer.indicator(255, 255, 0, 255, string.format(
                        "Pred: %.2f, Body: %.2f, Base: %.2f, JD: %.2f, Final: %.2f",
                        predicted_yaw, body_pose, base_correction, jitter_correction, final_correction))
                end
            
                -- Apply the final correction via the property list.
                if menu.other.misc.jitter_correction:get() then
                    plist.set(player, "Force body yaw", true)
                    plist.set(player, "Force body yaw value", final_correction)
                else
                    plist.set(player, "Force body yaw", false)
                    plist.set(player, "Force body yaw value", 0)
                end
            
                -- Store the current goal for use in the next frame.
                misc.aim_tools.correction.old_goal_feet_yaw[player] = current_goal
            end
        
            --------------------------------------------------
            -- (6) Update Correction for All Enemies.
            --------------------------------------------------
            misc.aim_tools.correction.update = function()
                local enemies = entity.get_players(true)
                for _, enemy in ipairs(enemies) do
                    misc.aim_tools.correction.correct_angle(enemy)
                end
            end
        
            --------------------------------------------------
            -- (7) Resolver Debug: Display Extended Resolver Data.
            --------------------------------------------------
            misc.aim_tools.correction.resolver_debug = function()
                local enemies = entity.get_players(true)
                for _, enemy in ipairs(enemies) do
                    if entity.is_alive(enemy) then
                        local hist = misc.aim_tools.correction.history[enemy]
                        if hist and hist.cur then
                            local debug_info = string.format("Player: %s, Yaw: %d, Diff: %.2f, Shot: %s", 
                                entity.get_player_name(enemy), 
                                hist.cur.yaw, 
                                hist.cur.yaw_diff or 0, 
                                tostring(hist.cur.recent_shot))
                            renderer.indicator(255, 0, 0, 255, debug_info)
                        end
                    end
                end
            end
        
            --------------------------------------------------
            -- (8) General Debug Display: Show Correction Values.
            --------------------------------------------------
            misc.aim_tools.correction.debug = function()
                if not menu.other.misc.jitter_correction_debug:get() or not menu.other.misc.jitter_correction:get() then return end
                local enemies = entity.get_players(true)
                for _, enemy in ipairs(enemies) do
                    if entity.is_alive(enemy) then
                        local resolver_value = math.floor(plist.get(enemy, "Force body yaw value"))
                        local name = entity.get_player_name(enemy)
                        renderer.indicator(255, 255, 255, 255, string.format("%s [ %.2f ]", name, resolver_value))
                    end
                end
            end
        end
    end

    -- misc.air_stop = { } do
    --     misc.air_stop.run = function(cmd)
    --         local lp = entity.get_local_player()
    --         if not lp or not entity.is_alive(lp) then return end

    --         if not menu.other.misc.air_stop:get() then return end

    --         local threat = client.current_threat()

    --         if threat then 
    --             vars.rage_bot.references.minimum_hitchance[1]:override()
    --             vars.rage_bot.references.minimum_damage[1]:override()
    --             vars.rage_bot.references.double_tap[1]:override()
    --         end

    --         if threat == nil then return end

    --         local weapon = entity.get_player_weapon(lp)
    --         local class_name = entity.get_classname(weapon)

    --         local is_scout = class_name == "CWeaponSSG08"
    --         if not is_scout then return end

    --         if not cmd.in_jump == 1 then return end

    --         local players = entity.get_players(true, false)

    --         for i = 1, #players do
    --             local enemy = players[i]

    --             local lp_origin = vector(entity.get_prop(lp, "m_vecOrigin"))
    --             local enemy_origin = vector(entity.get_prop(enemy, "m_vecOrigin"))
    
    --             local can_hit, damage = client.trace_bullet(lp, lp_origin.x, lp_origin.y, lp_origin.z, enemy_origin.x, enemy_origin.y, enemy_origin.z, false)
    
    --             local distance = enemy_origin.y - lp_origin.y
    
    --             if damage > 1 + menu.other.misc.air_stop_damage_multiplier:get() and distance < 1000 then
    --                 vars.rage_bot.references.minimum_hitchance[1]:override(menu.other.misc.air_stop_minimum_hitchance:get())
    --                 vars.rage_bot.references.minimum_damage[1]:override(damage)

    --                 if menu.other.misc.air_stop_dt_uncharge:get() then
    --                     vars.rage_bot.references.double_tap[1]:override(false)
    --                 else
    --                     vars.rage_bot.references.double_tap[1]:override()
    --                 end
    
    --                 cmd.in_speed = 1

    --                 if menu.other.misc.air_stop_auto_scope:get() then
    --                     cmd.in_attack2 = 1
    --                 end
    --             end
    --         end
    --     end
    -- end
end

local cfg_system = { } do
    cfg_system.db = "nyahook_"

    local package, data, encrypted, decrypted = pui.setup({ menu.anti_aim, menu.other }), "", "", ""
    
    configs_db = database.read(cfg_system.db) or { }
    configs_db.cfg_list = configs_db.cfg_list or {{'Default • Admin', 'W3siYnVpbGRlciI6W3sicGl0Y2giOiJEZWZhdWx0IiwiYWRkX2xlZnRfcmlnaHQiOnRydWUsImJvZHlfeWF3IjoiSml0dGVyIiwieWF3X2Ftb3VudCI6MCwiZm9yY2VfZGVmZW5zaXZlIjp0cnVlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOi0zMCwieWF3X3JpZ2h0Ijo0MywieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6IkRlZmF1bHQiLCJhZGRfbGVmdF9yaWdodCI6dHJ1ZSwiYm9keV95YXciOiJKaXR0ZXIiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjMsImVuYWJsZV9zdGF0ZSI6dHJ1ZSwieWF3X2ppdHRlcl9hbW91bnQiOjAsInlhd19qaXR0ZXIiOiJPZmYiLCJ5YXdfbGVmdCI6LTM2LCJ5YXdfcmlnaHQiOjUyLCJ5YXdfcmFuZG9taXplIjowfSx7InBpdGNoIjoiRGVmYXVsdCIsImFkZF9sZWZ0X3JpZ2h0Ijp0cnVlLCJib2R5X3lhdyI6IkppdHRlciIsInlhd19hbW91bnQiOi01LCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjMsImVuYWJsZV9zdGF0ZSI6dHJ1ZSwieWF3X2ppdHRlcl9hbW91bnQiOjAsInlhd19qaXR0ZXIiOiJPZmYiLCJ5YXdfbGVmdCI6LTI1LCJ5YXdfcmlnaHQiOjQ4LCJ5YXdfcmFuZG9taXplIjoxMn0seyJwaXRjaCI6IkRlZmF1bHQiLCJhZGRfbGVmdF9yaWdodCI6ZmFsc2UsImJvZHlfeWF3IjoiSml0dGVyIiwieWF3X2Ftb3VudCI6LTEyLCJmb3JjZV9kZWZlbnNpdmUiOnRydWUsImppdHRlcl9kZWxheSI6MSwiZW5hYmxlX3N0YXRlIjp0cnVlLCJ5YXdfaml0dGVyX2Ftb3VudCI6MCwieWF3X2ppdHRlciI6Ik9mZiIsInlhd19sZWZ0IjowLCJ5YXdfcmlnaHQiOjAsInlhd19yYW5kb21pemUiOjB9LHsicGl0Y2giOiJEZWZhdWx0IiwiYWRkX2xlZnRfcmlnaHQiOnRydWUsImJvZHlfeWF3IjoiSml0dGVyIiwieWF3X2Ftb3VudCI6MCwiZm9yY2VfZGVmZW5zaXZlIjp0cnVlLCJqaXR0ZXJfZGVsYXkiOjIsImVuYWJsZV9zdGF0ZSI6dHJ1ZSwieWF3X2ppdHRlcl9hbW91bnQiOjAsInlhd19qaXR0ZXIiOiJPZmYiLCJ5YXdfbGVmdCI6LTI4LCJ5YXdfcmlnaHQiOjQzLCJ5YXdfcmFuZG9taXplIjoxMH0seyJwaXRjaCI6Ik9mZiIsImFkZF9sZWZ0X3JpZ2h0IjpmYWxzZSwiYm9keV95YXciOiJPZmYiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOjAsInlhd19yaWdodCI6MCwieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6Ik9mZiIsImFkZF9sZWZ0X3JpZ2h0IjpmYWxzZSwiYm9keV95YXciOiJPZmYiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOjAsInlhd19yaWdodCI6MCwieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6Ik9mZiIsImFkZF9sZWZ0X3JpZ2h0IjpmYWxzZSwiYm9keV95YXciOiJPZmYiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOjAsInlhd19yaWdodCI6MCwieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6Ik9mZiIsImFkZF9sZWZ0X3JpZ2h0IjpmYWxzZSwiYm9keV95YXciOiJPZmYiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOjAsInlhd19yaWdodCI6MCwieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6IkRlZmF1bHQiLCJhZGRfbGVmdF9yaWdodCI6ZmFsc2UsImJvZHlfeWF3IjoiU3RhdGljIiwieWF3X2Ftb3VudCI6MCwiZm9yY2VfZGVmZW5zaXZlIjpmYWxzZSwiaml0dGVyX2RlbGF5IjoxLCJlbmFibGVfc3RhdGUiOmZhbHNlLCJ5YXdfaml0dGVyX2Ftb3VudCI6MCwieWF3X2ppdHRlciI6Ik9mZiIsInlhd19sZWZ0IjowLCJ5YXdfcmlnaHQiOjAsInlhd19yYW5kb21pemUiOjB9XSwiaGVpZ2h0X2RpZmZlcmVuY2UiOjEyNSwidHdlYWtzIjpbIkF2b2lkIGJhY2tzdGFiIiwiRmFzdCBsYWRkZXIiLCJTYWZlIGhlYWQiLCJ+Il0sIm1hbnVhbF95YXdfZm9yd2FyZCI6WzEsMzgsIn4iXSwibWFudWFsX3lhd19sZWZ0IjpbMSw5MCwifiJdLCJhdm9pZF9iYWNrc3RhYl9kaXN0YW5jZSI6MzAwLCJtYW51YWxfeWF3X3JpZ2h0IjpbMSw2NywifiJdLCJjdXJyZW50X3N0YXRlIjoiQWlyKyIsInNhZmVfaGVhZF9zdGF0ZXMiOlsiS25pZmUiLCJUYXNlciIsIkFib3ZlIGVuZW15IiwifiJdLCJmcmVlc3RhbmRfaG90a2V5IjpbMSwxOCwifiJdfSx7InZpc3VhbHMiOnsiY3VzdG9tX3Njb3BlX292ZXJsYXkiOnRydWUsImN1c3RvbV9zY29wZV9vdmVybGF5X3NpemUiOjE1MCwiZGFtYWdlX2luZGljYXRvciI6dHJ1ZSwiY3Jvc3NfbWFya2VyIjpmYWxzZSwiY3VzdG9tX3Njb3BlX292ZXJsYXlfY29sb3IiOiIjOUU5RTlFRkYiLCJjcm9zc2hhaXJfaW5kaWNhdG9ycyI6ZmFsc2UsImN1c3RvbV9zY29wZV9vdmVybGF5X2dhcCI6MywibWFudWFsX2Fycm93c19jb2xvciI6IiNGRkZGRkZGRiIsIm1hbnVhbF9hcnJvd3MiOnRydWUsIm1hbnVhbF9hcnJvd3Nfc3R5bGUiOiJNb2Rlcm4iLCJjcm9zc2hhaXJfaW5kaWNhdG9yc19vZmZzZXQiOjE1LCJjcm9zc2hhaXJfaW5kaWNhdG9yc19jb2xvciI6IiNCMDkzQzNGRiJ9LCJtaXNjIjp7ImFpcl9sZWdzIjoiRGlzYWJsZWQiLCJtaXNzX2NvbG9yIjoiI0NDOEE4QUZGIiwiYWRkb25zIjpbIkJvZHkgTGVhbiIsIn4iXSwiYWltYm90X2xvZ3MiOnRydWUsImdyb3VuZF9sZWdzIjoiSml0dGVyIiwiY29uc29sZV9maWx0ZXIiOnRydWUsIm5vdGlmeV9vdXRwdXQiOnRydWUsImdyb3VuZF9sZWdzX3R5cGUiOiJSYW5kb21pemVkIiwiaGl0X2NvbG9yIjoiIzkzOTZDRkZGIiwiYW5pbWF0aW9ucyI6dHJ1ZX19XQ=='}}
    configs_db.menu_list = configs_db.menu_list or {'Defaul • Admin'}
    configs_db.cfg_list[1][2] = "W3siYnVpbGRlciI6W3sicGl0Y2giOiJEZWZhdWx0IiwiYWRkX2xlZnRfcmlnaHQiOnRydWUsImJvZHlfeWF3IjoiSml0dGVyIiwieWF3X2Ftb3VudCI6MCwiZm9yY2VfZGVmZW5zaXZlIjp0cnVlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOi0zMCwieWF3X3JpZ2h0Ijo0MywieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6IkRlZmF1bHQiLCJhZGRfbGVmdF9yaWdodCI6dHJ1ZSwiYm9keV95YXciOiJKaXR0ZXIiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjMsImVuYWJsZV9zdGF0ZSI6dHJ1ZSwieWF3X2ppdHRlcl9hbW91bnQiOjAsInlhd19qaXR0ZXIiOiJPZmYiLCJ5YXdfbGVmdCI6LTM2LCJ5YXdfcmlnaHQiOjUyLCJ5YXdfcmFuZG9taXplIjowfSx7InBpdGNoIjoiRGVmYXVsdCIsImFkZF9sZWZ0X3JpZ2h0Ijp0cnVlLCJib2R5X3lhdyI6IkppdHRlciIsInlhd19hbW91bnQiOi01LCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjMsImVuYWJsZV9zdGF0ZSI6dHJ1ZSwieWF3X2ppdHRlcl9hbW91bnQiOjAsInlhd19qaXR0ZXIiOiJPZmYiLCJ5YXdfbGVmdCI6LTI1LCJ5YXdfcmlnaHQiOjQ4LCJ5YXdfcmFuZG9taXplIjoxMn0seyJwaXRjaCI6IkRlZmF1bHQiLCJhZGRfbGVmdF9yaWdodCI6ZmFsc2UsImJvZHlfeWF3IjoiSml0dGVyIiwieWF3X2Ftb3VudCI6LTEyLCJmb3JjZV9kZWZlbnNpdmUiOnRydWUsImppdHRlcl9kZWxheSI6MSwiZW5hYmxlX3N0YXRlIjp0cnVlLCJ5YXdfaml0dGVyX2Ftb3VudCI6MCwieWF3X2ppdHRlciI6Ik9mZiIsInlhd19sZWZ0IjowLCJ5YXdfcmlnaHQiOjAsInlhd19yYW5kb21pemUiOjB9LHsicGl0Y2giOiJEZWZhdWx0IiwiYWRkX2xlZnRfcmlnaHQiOnRydWUsImJvZHlfeWF3IjoiSml0dGVyIiwieWF3X2Ftb3VudCI6MCwiZm9yY2VfZGVmZW5zaXZlIjp0cnVlLCJqaXR0ZXJfZGVsYXkiOjIsImVuYWJsZV9zdGF0ZSI6dHJ1ZSwieWF3X2ppdHRlcl9hbW91bnQiOjAsInlhd19qaXR0ZXIiOiJPZmYiLCJ5YXdfbGVmdCI6LTI4LCJ5YXdfcmlnaHQiOjQzLCJ5YXdfcmFuZG9taXplIjoxMH0seyJwaXRjaCI6Ik9mZiIsImFkZF9sZWZ0X3JpZ2h0IjpmYWxzZSwiYm9keV95YXciOiJPZmYiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOjAsInlhd19yaWdodCI6MCwieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6Ik9mZiIsImFkZF9sZWZ0X3JpZ2h0IjpmYWxzZSwiYm9keV95YXciOiJPZmYiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOjAsInlhd19yaWdodCI6MCwieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6Ik9mZiIsImFkZF9sZWZ0X3JpZ2h0IjpmYWxzZSwiYm9keV95YXciOiJPZmYiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOjAsInlhd19yaWdodCI6MCwieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6Ik9mZiIsImFkZF9sZWZ0X3JpZ2h0IjpmYWxzZSwiYm9keV95YXciOiJPZmYiLCJ5YXdfYW1vdW50IjowLCJmb3JjZV9kZWZlbnNpdmUiOmZhbHNlLCJqaXR0ZXJfZGVsYXkiOjEsImVuYWJsZV9zdGF0ZSI6ZmFsc2UsInlhd19qaXR0ZXJfYW1vdW50IjowLCJ5YXdfaml0dGVyIjoiT2ZmIiwieWF3X2xlZnQiOjAsInlhd19yaWdodCI6MCwieWF3X3JhbmRvbWl6ZSI6MH0seyJwaXRjaCI6IkRlZmF1bHQiLCJhZGRfbGVmdF9yaWdodCI6ZmFsc2UsImJvZHlfeWF3IjoiU3RhdGljIiwieWF3X2Ftb3VudCI6MCwiZm9yY2VfZGVmZW5zaXZlIjpmYWxzZSwiaml0dGVyX2RlbGF5IjoxLCJlbmFibGVfc3RhdGUiOmZhbHNlLCJ5YXdfaml0dGVyX2Ftb3VudCI6MCwieWF3X2ppdHRlciI6Ik9mZiIsInlhd19sZWZ0IjowLCJ5YXdfcmlnaHQiOjAsInlhd19yYW5kb21pemUiOjB9XSwiaGVpZ2h0X2RpZmZlcmVuY2UiOjEyNSwidHdlYWtzIjpbIkF2b2lkIGJhY2tzdGFiIiwiRmFzdCBsYWRkZXIiLCJTYWZlIGhlYWQiLCJ+Il0sIm1hbnVhbF95YXdfZm9yd2FyZCI6WzEsMzgsIn4iXSwibWFudWFsX3lhd19sZWZ0IjpbMSw5MCwifiJdLCJhdm9pZF9iYWNrc3RhYl9kaXN0YW5jZSI6MzAwLCJtYW51YWxfeWF3X3JpZ2h0IjpbMSw2NywifiJdLCJjdXJyZW50X3N0YXRlIjoiQWlyKyIsInNhZmVfaGVhZF9zdGF0ZXMiOlsiS25pZmUiLCJUYXNlciIsIkFib3ZlIGVuZW15IiwifiJdLCJmcmVlc3RhbmRfaG90a2V5IjpbMSwxOCwifiJdfSx7InZpc3VhbHMiOnsiY3VzdG9tX3Njb3BlX292ZXJsYXkiOnRydWUsImN1c3RvbV9zY29wZV9vdmVybGF5X3NpemUiOjE1MCwiZGFtYWdlX2luZGljYXRvciI6dHJ1ZSwiY3Jvc3NfbWFya2VyIjpmYWxzZSwiY3VzdG9tX3Njb3BlX292ZXJsYXlfY29sb3IiOiIjOUU5RTlFRkYiLCJjcm9zc2hhaXJfaW5kaWNhdG9ycyI6ZmFsc2UsImN1c3RvbV9zY29wZV9vdmVybGF5X2dhcCI6MywibWFudWFsX2Fycm93c19jb2xvciI6IiNGRkZGRkZGRiIsIm1hbnVhbF9hcnJvd3MiOnRydWUsIm1hbnVhbF9hcnJvd3Nfc3R5bGUiOiJNb2Rlcm4iLCJjcm9zc2hhaXJfaW5kaWNhdG9yc19vZmZzZXQiOjE1LCJjcm9zc2hhaXJfaW5kaWNhdG9yc19jb2xvciI6IiNCMDkzQzNGRiJ9LCJtaXNjIjp7ImFpcl9sZWdzIjoiRGlzYWJsZWQiLCJtaXNzX2NvbG9yIjoiI0NDOEE4QUZGIiwiYWRkb25zIjpbIkJvZHkgTGVhbiIsIn4iXSwiYWltYm90X2xvZ3MiOnRydWUsImdyb3VuZF9sZWdzIjoiSml0dGVyIiwiY29uc29sZV9maWx0ZXIiOnRydWUsIm5vdGlmeV9vdXRwdXQiOnRydWUsImdyb3VuZF9sZWdzX3R5cGUiOiJSYW5kb21pemVkIiwiaGl0X2NvbG9yIjoiIzkzOTZDRkZGIiwiYW5pbWF0aW9ucyI6dHJ1ZX19XQ=="
    
    cfg_system.save_config = function(id)
        if id == 1 then 
            client.exec("play resource/warning.wav")
            return 
        end
        if configs_db.cfg_list[id] == nil then
            client.exec("play resource/warning.wav")
            return
        end
        client.exec("play ui\beepclear")
        if configs_db.cfg_list[id][2] == nil then
            client.exec("play resource/warning.wav")
            return
        end
        
        local raw = package:save()
        configs_db.cfg_list[id][2] = base64.encode(json.stringify(raw))
        database.write(cfg_system.db, configs_db)
        client.exec("play ui\beepclear")
    end
    cfg_system.create_config = function(name)
        if type(name) ~= 'string' then return end
        if name == nil or name == '' or name == ' ' then
            client.exec("play resource/warning.wav")
            return
        end
        for i= #configs_db.menu_list, 1, -1 do
            if configs_db.menu_list[i] == name then
                client.exec("play resource/warning.wav")
                return
            end
        end
        
        if #configs_db.cfg_list > 6 then
            client.exec("play resource/warning.wav")
            return
        end
    
        local name = name .. " • Admin"
        local completed = {name, ''}
        client.exec("play ui\beepclear")
        table.insert(configs_db.cfg_list, completed)
        table.insert(configs_db.menu_list, name)
        database.write(cfg_system.db, configs_db)
    end
    cfg_system.remove_config = function(id)
        if id == 1 then
            client.exec("play resource/warning.wav")
            return    
        end
        local item = configs_db.cfg_list[id][1]
        for i= #configs_db.cfg_list, 1, -1 do
            if configs_db.cfg_list[i][1] == item then
                table.remove(configs_db.cfg_list, i)
                table.remove(configs_db.menu_list, i)
            end
        end
        client.exec("play ui\beepclear")
        database.write(cfg_system.db, configs_db)
    end
    cfg_system.load_config = function(id)
        if configs_db.cfg_list[id][2] == nil or configs_db.cfg_list[id][2] == '' then
                client.exec("play resource/warning.wav")
                return
            end
        if id > #configs_db.cfg_list then
            client.exec("play resource/warning.wav")
            return
        end
        client.exec("play ui\beepclear")
        package:load(json.parse(base64.decode(configs_db.cfg_list[id][2])))
    end

    menu.configs.create:set_callback(function() 
        cfg_system.create_config(menu.configs.name:get())
        menu.configs.list:update(configs_db.menu_list)
    end)
    menu.configs.load:set_callback(function() 
        cfg_system.load_config(menu.configs.list:get() + 1)
        menu.configs.list:update(configs_db.menu_list)
    end)
    menu.configs.save:set_callback(function() 
        cfg_system.save_config(menu.configs.list:get() + 1)
    end)
    menu.configs.delete:set_callback(function() 
        cfg_system.remove_config(menu.configs.list:get() + 1)
        menu.configs.list:update(configs_db.menu_list)
    end)
    menu.configs.import:set_callback(function() 
        package:load(json.parse(base64.decode(clipboard.get())))
    end)
    menu.configs.export:set_callback(function() 
        clipboard.set(base64.encode(json.stringify(package:save())))
    end)
    menu.configs.list:update(configs_db.menu_list)
end

pui.traverse(menu.configs, function(item)
    item:depend({menu.tab_switcher, "Home"})
end)

pui.traverse(menu.anti_aim, function(item)
    item:depend({menu.tab_switcher, "Anti-aim"})
end)

pui.traverse(menu.other, function(item)
    item:depend({menu.tab_switcher, "Other"})
end)

events.paint_ui:set(function()
    vars.visuals.references.scope_overlay:override(true)
end)

events.paint:set(function(c)
    visuals.watermark.paint()
    visuals.exploit_indication.paint()
    -- visuals.crosshair_indicators.paint()
    visuals.damage_indicator.paint()
    visuals.cross_marker.paint(c)
    visuals.manual_arrows.paint()
    visuals.custom_scope_overlay.paint()
    visuals.aspect_ratio.run()

    misc.aimbot_logs.notifications()
    misc.aim_tools.correction.debug()
end)

events.override_view:set(function(e)
    visuals.animated_zoom.run(e)
end)

events.pre_render:set(function()
    misc.animations.pre_render()
end)

events.setup_command:set(function(cmd)
    anti_aim.run(cmd)
    -- misc.air_stop.run(cmd)
end)

events.run_command:set(function(cmd)
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then return end

    anti_aim.exploit.breaker.cmd = cmd.command_number

    local tickbase = entity.get_prop(lp, "m_nTickBase") or 0
    local client_latency = client.latency()
    local shift = math.floor(tickbase - globals.tickcount() - 3 - toticks(client_latency) * 0.5 + 0.5 * (client_latency * 10))
    local wanted = -14 + (vars.rage_bot.references.double_tap_fl_limit:get() - 1) + 3
    anti_aim.exploit.charged = shift <= wanted

    misc.aim_tools.correction.update()
end)

events.predict_command:set(function(cmd)
    local lp = entity.get_local_player()
    if not lp or not entity.is_alive(lp) then return end

    if cmd.command_number == anti_aim.exploit.breaker.cmd then
        local tickbase = entity.get_prop(lp, "m_nTickBase")
        anti_aim.exploit.breaker.check = math.max(tickbase, anti_aim.exploit.breaker.check)
        anti_aim.exploit.breaker.tick = math.min(14, math.max(1, anti_aim.exploit.breaker.check-tickbase-1))
        anti_aim.exploit.breaker.cmd = 0
    end
end)

events.level_init:set(function()
    anti_aim.exploit.breaker.tick = 0
    anti_aim.exploit.breaker.check = 0
    anti_aim.exploit.breaker.cmd = 0
end)

events.aim_fire:set(function(c)
    visuals.cross_marker.aim_fire(c)
    misc.aimbot_logs.aim_fire(c)
end)

events.aim_hit:set(function(c)
    misc.aimbot_logs.hit.aim_hit(c)
end)

events.aim_miss:set(function(c)
    misc.aimbot_logs.hit.aim_miss(c)
end)

events.round_prestart:set(function()
    visuals.cross_marker.queue = {}
end)

events.paint_ui:set(function()   
    pui.traverse(vars.anti_aim.references.elements, function(item)
        item:set_visible(false)
    end)
end)

events.shutdown:set(function()
    pui.traverse(vars.anti_aim.references.elements, function(item)
        item:set_visible(true)
    end)

    client.set_cvar("r_aspectratio", 0)
end)
